  {
    "entry": "src/index.ts",
    "files": [
      {
        "path": "package.json",
        "content": "{\n  \"name\": \"ks-autoscaling\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"main\": \"dist/index.js\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"dependencies\": {\n    \"qs\": \"^6.13.0\"\n  }\n}\n"
      },
      {
        "path": "src/components/CustomScalingSimpleStatus/index.styles.ts",
        "content": "import { StatusDot } from '@kubed/components';\nimport styled from 'styled-components';\n\nexport const Container = styled.div`\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  gap: 8px;\n`;\n\nexport const Item = styled.div`\n  width: 20px;\n  height: 20px;\n  background: #f9fbfd;\n  border-radius: 50%;\n  text-align: center;\n  line-height: 18px;\n\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  &:not(:last-child) {\n    margin-right: 4px;\n    position: relative;\n\n    &::after {\n      width: 8px;\n      height: 4px;\n      background: #f9fbfd;\n      content: '';\n      position: absolute;\n      top: 50%;\n      right: 0;\n      transform: translate3d(100%, -50%, 0);\n    }\n\n    &::before {\n      left: -4px;\n    }\n  }\n`;\n\nexport const TextItemTitle = styled.div`\n  display: flex;\n  align-items: center;\n\n  & > span:last-child {\n    margin-left: 6px;\n    font-weight: 600;\n    font-size: 12px;\n    line-height: 20px;\n  }\n`;\n\nexport const TextItem = styled.div`\n  margin-bottom: 8px;\n\n  ul {\n    color: #abb4be;\n\n    li {\n      line-height: 20px;\n    }\n  }\n`;\n\nexport const TooltipContent = styled.div`\n  .width-full {\n    width: 100%;\n  }\n`;\n\nexport const ToolTipTitle = styled.div`\n  font-weight: 600;\n  font-size: 12px;\n  line-height: 20px;\n  margin-bottom: 8px;\n  margin-top: 8px;\n`;\n\nexport const CreatingStatus = styled(StatusDot)`\n  & > span:first-child {\n    background-color: rgba(50, 157, 206, 16%);\n    box-shadow: 0 8px 16px 0 rgb(50 157 206 / 36%);\n    &::before {\n      background-color: #329dce;\n    }\n  }\n`;\n\n"
      },
      {
        "path": "src/components/CustomScalingSimpleStatus/index.tsx",
        "content": "import { Icon } from '@ks-console/shared';\nimport { Button, StatusDot, Tooltip } from '@kubed/components';\nimport { Information } from '@kubed/icons';\nimport React from 'react';\n\nimport { TextItem, TextItemTitle, TooltipContent, ToolTipTitle, Container, CreatingStatus } from './index.styles';\n\nconst ICON_TYPES = {\n  False: { name: 'CloseCircleDuotone', color: '#AB2F29' },\n  True: { name: 'success', color: '#55BC8A' },\n  Unknown: { name: 'question', color: '#E0992C' },\n  Paused: { name: 'pause', color: '#E0992C' },\n};\n\nconst STATUS_TITLE = {\n  Ready: 'KS_AUTOSCALING.STRETCH_OBJECT_READY',\n  Active: 'KS_AUTOSCALING.TRIGGER_ACTIVE',\n  Fallback: 'KS_AUTOSCALING.RETRACTOR_FALLBACK',\n  Paused: 'KS_AUTOSCALING.PAUSE',\n};\n\ninterface Condition {\n  status: keyof typeof ICON_TYPES;\n  type: keyof typeof STATUS_TITLE;\n  reason?: string;\n  message?: string;\n}\n\ninterface CustomScalingStatusProps {\n  status: {\n    conditions?: Condition[];\n  };\n  toEvent: () => void;\n  isReady: boolean;\n}\n\n\nexport default function CustomScalingStatus({\n  status,\n  toEvent,\n  isReady,\n}: CustomScalingStatusProps) {\n  const conditions = status?.conditions ?? [];\n\n  const renderIconItem = (_status: keyof typeof ICON_TYPES) => {\n    return (\n      <Icon\n        name={ICON_TYPES[_status].name}\n        size={16}\n        color=\"#fff\"\n        style={{\n          fill: ICON_TYPES[_status].color,\n        }}\n      />\n    );\n  };\n\n  const renderToolTip = () => {\n    return (\n      <TooltipContent>\n        <ToolTipTitle>{t('STATUS_INFORMATION')}</ToolTipTitle>\n        {conditions.map((item, index) => (\n          <TextItem key={index}>\n            <TextItemTitle>\n              {renderIconItem(item.status)}\n              <span>{t(STATUS_TITLE[item.type as 'Active'])}</span>\n            </TextItemTitle>\n            <ul>\n              <li>{t('STATUS_VALUE', { value: item.status })}</li>\n              <li>{item.reason && t('REASON_VALUE', { value: item.reason })}</li>\n              <li>{item.message && t('MESSAGE_VALUE', { value: item.message })}</li>\n            </ul>\n          </TextItem>\n        ))}\n        <Button variant=\"filled\" color=\"primary\" onClick={toEvent} className={'width-full'}>\n          {t('VIEW_EVENTS')}\n        </Button>\n      </TooltipContent>\n    );\n  };\n\n  if (!status.conditions?.length) {\n    return <CreatingStatus>{t('KS_AUTOSCALING.CREATING')}</CreatingStatus>;\n  }\n\n  if (isReady) {\n    return <StatusDot color=\"success\">{t('KS_AUTOSCALING.NORMAL')}</StatusDot>;\n  }\n  return (\n    <Container>\n      <StatusDot color=\"warning\">{t('KS_AUTOSCALING.ABNORMAL')}</StatusDot>\n      <Tooltip content={renderToolTip()} maxWidth={300} placement={'right'} interactive>\n        <Information size={16} />\n      </Tooltip>\n    </Container>\n  );\n}\n"
      },
      {
        "path": "src/components/CustomScalingStatus/index.styles.ts",
        "content": "import styled from 'styled-components';\n\nexport const Container = styled.div`\n  display: inline-flex;\n`;\n\nexport const Item = styled.div`\n  width: 20px;\n  height: 20px;\n  background: #f9fbfd;\n  border-radius: 50%;\n  text-align: center;\n  line-height: 18px;\n\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  &:not(:last-child) {\n    margin-right: 4px;\n    position: relative;\n\n    &::after {\n      width: 8px;\n      height: 4px;\n      background: #f9fbfd;\n      content: '';\n      position: absolute;\n      top: 50%;\n      right: 0;\n      transform: translate3d(100%, -50%, 0);\n    }\n\n    &::before {\n      left: -4px;\n    }\n  }\n`;\n\nexport const TextItemTitle = styled.div`\n  display: flex;\n  align-items: center;\n\n  & > span:last-child {\n    margin-left: 6px;\n    font-weight: 600;\n    font-size: 12px;\n    line-height: 20px;\n  }\n`;\n\nexport const TextItem = styled.div`\n  margin-bottom: 8px;\n\n  ul {\n    color: #abb4be;\n\n    li {\n      line-height: 20px;\n    }\n  }\n`;\n\nexport const TooltipContent = styled.div`\n  .width-full {\n    width: 100%;\n  }\n`;\n\nexport const ToolTipTitle = styled.div`\n  font-weight: 600;\n  font-size: 12px;\n  line-height: 20px;\n  margin-bottom: 8px;\n  margin-top: 8px;\n`;\n"
      },
      {
        "path": "src/components/CustomScalingStatus/index.tsx",
        "content": "import React from 'react';\nimport { Icon } from '@ks-console/shared';\nimport { Button, Tooltip } from '@kubed/components';\nimport {\n  Item,\n  TextItem,\n  TextItemTitle,\n  Container,\n  TooltipContent,\n  ToolTipTitle,\n} from './index.styles';\n\nconst ICON_TYPES = {\n  False: { name: 'CloseCircleDuotone', color: '#AB2F29' },\n  True: { name: 'success', color: '#55BC8A' },\n  Unknown: { name: 'question', color: '#E0992C' },\n  Paused: { name: 'pause', color: '#E0992C' },\n};\n\nconst STATUS_TITLE = {\n  Ready: 'KS_AUTOSCALING.STRETCH_OBJECT_READY',\n  Active: 'KS_AUTOSCALING.TRIGGER_ACTIVE',\n  Fallback: 'KS_AUTOSCALING.RETRACTOR_FALLBACK',\n  Paused: 'KS_AUTOSCALING.PAUSE',\n};\n\ninterface Condition {\n  status: keyof typeof ICON_TYPES;\n  type: keyof typeof STATUS_TITLE;\n  reason?: string;\n  message?: string;\n}\n\ninterface CustomScalingStatusProps {\n  status: {\n    conditions?: Condition[];\n  };\n  toEvent: () => void;\n}\n\nexport default function CustomScalingStatus({ status, toEvent }: CustomScalingStatusProps) {\n  const conditions = status?.conditions ?? [];\n\n  const renderIconItem = (_status: keyof typeof ICON_TYPES) => {\n    return (\n      <Icon\n        name={ICON_TYPES[_status].name}\n        size={16}\n        color=\"#fff\"\n        style={{\n          fill: ICON_TYPES[_status].color,\n        }}\n      />\n    );\n  };\n\n  const renderToolTip = () => {\n    return (\n      <TooltipContent>\n        <ToolTipTitle>{t('STATUS_INFORMATION')}</ToolTipTitle>\n        {conditions.map((item, index) => (\n          <TextItem key={index}>\n            <TextItemTitle>\n              {renderIconItem(item.status)}\n              <span>{t(STATUS_TITLE[item.type as 'Active'])}</span>\n            </TextItemTitle>\n            <ul>\n              <li>{t('STATUS_VALUE', { value: item.status })}</li>\n              <li>{item.reason && t('REASON_VALUE', { value: item.reason })}</li>\n              <li>{item.message && t('MESSAGE_VALUE', { value: item.message })}</li>\n            </ul>\n          </TextItem>\n        ))}\n        <Button variant=\"filled\" color=\"primary\" onClick={toEvent} className={'width-full'}>\n          {t('VIEW_EVENTS')}\n        </Button>\n      </TooltipContent>\n    );\n  };\n\n  return (\n    <Tooltip content={renderToolTip()} maxWidth={300} placement={'right'} interactive>\n      <Container>\n        {conditions.map((item, index) => (\n          <Item key={index}>{renderIconItem(item.status)}</Item>\n        ))}\n      </Container>\n    </Tooltip>\n  );\n}\n"
      },
      {
        "path": "src/components/Empty/index.styles.ts",
        "content": "import styled from 'styled-components';\n\nexport const EmptyWrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  gap: 20px;\n`;\n\nexport const EmptyIcon = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  padding: 6px;\n\n  width: 60px;\n  height: 60px;\n\n  background: ${({ theme }) => theme.palette.accents_1};\n  border-radius: 100px 0px 100px 100px;\n`;\n\nexport const EmptyTitle = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  gap: 4px;\n  & div:first-child {\n    font-style: normal;\n    font-weight: 600;\n    font-size: 14px;\n    line-height: 20px;\n    text-align: center;\n    color: ${({ theme }) => theme.palette.accents_8};\n  }\n  & div:nth-of-type(2) {\n    font-style: normal;\n    font-weight: 400;\n    font-size: 12px;\n    line-height: 20px;\n    text-align: center;\n    color: ${({ theme }) => theme.palette.colors.dark[0]};\n  }\n`;\n\nexport const EmptyAction = styled.div`\n  display: flex;\n  gap: 12px;\n  justify-content: center;\n`;\n"
      },
      {
        "path": "src/components/Empty/index.tsx",
        "content": "import * as React from 'react';\n\nimport { Button } from '@kubed/components';\nimport { EmptyAction, EmptyIcon, EmptyTitle, EmptyWrapper } from './index.styles';\nimport { Warning } from '@kubed/icons';\n\ninterface EmptyProps {\n  icon?: React.ReactNode;\n  title?: React.ReactNode;\n  desc?: React.ReactNode;\n  actions?: React.ReactNode;\n}\n\nexport const Empty: React.FC<EmptyProps> = props => {\n  const { icon, title, desc, actions } = props;\n  return (\n    <EmptyWrapper>\n      <EmptyIcon>{icon ?? <Warning size={48} />}</EmptyIcon>\n      <EmptyTitle>\n        <div>{title ?? t('NO_DATA')}</div>\n        {desc && <div>{desc}</div>}\n      </EmptyTitle>\n      {actions && <EmptyAction>{actions}</EmptyAction>}\n    </EmptyWrapper>\n  );\n};\n"
      },
      {
        "path": "src/components/ExtensionConsoleV3Embed/index.ts",
        "content": "import { getExtensionConsoleV3Embed } from '@ks-console/shared';\nimport { EMBED_BASE_URL, EMBED_NAME } from '../../constants';\n\nconst { initWujie, ExtensionConsoleV3Embed, V3ModalObserver, triggerV3Action } =\n  getExtensionConsoleV3Embed({\n    name: EMBED_NAME,\n    baseUrl: EMBED_BASE_URL,\n  });\n\nexport { initWujie, ExtensionConsoleV3Embed, V3ModalObserver, triggerV3Action };\n"
      },
      {
        "path": "src/components/ExtensionConsoleV3Embed/index.tsx",
        "content": "import React from 'react';\nimport qs from 'qs';\n\nimport {\n  ExtensionConsoleV3Embed as BaseExtensionConsoleV3Embed,\n  setupWujieApp,\n  useEventEmitter,\n} from '@ks-console/shared';\n\nimport { EMBED_NAME, EMBED_BASE_URL } from '../../constants';\n\ninterface ExtensionConsoleV3EmbedProps<T extends Record<string, any> = Record<string, any>> {\n  path: string;\n  searchParams?: T;\n}\n\nexport function ExtensionConsoleV3Embed({ path, searchParams }: ExtensionConsoleV3EmbedProps) {\n  const query = qs.stringify(searchParams, { addQueryPrefix: true });\n  const url = `${EMBED_BASE_URL}${path}${query}`;\n\n  return <BaseExtensionConsoleV3Embed name={EMBED_NAME} url={url} />;\n}\n\nexport function initWujie() {\n  setupWujieApp({\n    name: EMBED_NAME,\n    url: `${EMBED_BASE_URL}/`,\n    afterMount: appWindow => {\n      const { $emit } = useEventEmitter();\n      $emit('afterMountConsoleV3', appWindow);\n    },\n    afterUnmount: appWindow => {\n      const { $emit } = useEventEmitter();\n      $emit('afterUnmountConsoleV3', appWindow);\n    },\n  });\n}\n"
      },
      {
        "path": "src/components/MonitorsSheet/index.tsx",
        "content": "/*\n * Please refer to the LICENSE file in the root directory of the project.\n * https://github.com/kubesphere/console/blob/master/LICENSE\n */\n\nimport { Sheet as SheetPrimitive } from '@kubed/components';\nimport * as React from 'react';\nimport styled from 'styled-components';\nimport { ConfigConstants } from '@ks-console/shared';\nimport Monitorings from './item';\nconst { Sheet, SheetContent, SheetHeader, SheetFieldTitle } = SheetPrimitive;\ninterface MonitorsSheetProps\n  extends React.ComponentProps<typeof SheetPrimitive.Sheet>,\n    React.ComponentProps<typeof Monitorings> {\n  headerTitle: React.ReactNode;\n  headerDescription?: React.ReactNode;\n  headerIcon?: React.ReactNode;\n  sheetContentProps?: React.ComponentProps<typeof SheetPrimitive.SheetContent>;\n}\n\nconst { SIDER_COLLAPSED } = ConfigConstants;\n\nexport const MonitorsSheet = (props: MonitorsSheetProps) => {\n  const {\n    open,\n    onOpenChange,\n    headerTitle = t('LOGS'),\n    headerDescription,\n    headerIcon,\n    sheetContentProps,\n    ...rest\n  } = props;\n\n  const SheetContentChildrenWrapper = styled.div`\n    display: grid;\n    grid-template-rows: 60px 1fr;\n    height: 100%;\n    .kubed-modal-title > div {\n      min-height: 40px;\n    }\n    .container-log-card {\n      width: 100%;\n      overflow: auto;\n    }\n  `;\n\n  const Content = styled.div`\n    padding: 20px;\n    background-color: ${props => props.theme.palette.accents_1};\n    height: 100%;\n    overflow: auto;\n  `;\n\n  const siderCollapsed = localStorage.getItem(SIDER_COLLAPSED);\n  const width = siderCollapsed === 'true' ? 'calc( 100vw - 60px )' : 'calc( 100vw - 220px )';\n  return (\n    <Sheet open={open} onOpenChange={onOpenChange}>\n      <SheetContent\n        width={width}\n        side={'right'}\n        {...sheetContentProps}\n        // onPointerDownOutside={avoidDefaultDomBehavior}\n        // onInteractOutside={avoidDefaultDomBehavior}\n      >\n        <SheetContentChildrenWrapper>\n          <SheetHeader>\n            <SheetFieldTitle\n              title={headerTitle}\n              description={headerDescription}\n              titleIcon={headerIcon}\n            />\n          </SheetHeader>\n          <Content>\n            <Monitorings {...rest} />\n          </Content>\n        </SheetContentChildrenWrapper>\n      </SheetContent>\n    </Sheet>\n  );\n};\n"
      },
      {
        "path": "src/components/MonitorsSheet/item.tsx",
        "content": "/*\n * Please refer to the LICENSE file in the root directory of the project.\n * https://github.com/kubesphere/console/blob/master/LICENSE\n */\n\nimport { useCacheStore as useStore } from '@ks-console/shared';\nimport { get, isEmpty, uniq } from 'lodash';\nimport React, { useState } from 'react';\nimport { useMutation } from 'react-query';\nimport { useParams } from 'react-router-dom';\nimport styled from 'styled-components';\nimport {\n  MonitorController,\n  SimpleArea,\n  hideGPUByLicense,\n  monitorStore,\n  getAreaChartOps,\n  podMonitiorStore,\n  getZeroValues,\n  PodsStore,\n  // useCacheStore as useStore,\n} from '@ks-console/shared';\n\nconst MetricTypes = {\n  cpu_usage: 'pod_cpu_usage',\n  memory_usage: 'pod_memory_usage_wo_cache',\n  gpu_usage: 'pod_gpu_usage',\n  gpu_memory_usage: 'pod_gpu_memory_usage',\n  net_transmitted: 'pod_net_bytes_transmitted',\n  net_received: 'pod_net_bytes_received',\n};\nconst { getApi, fetchSortedMetrics } = podMonitiorStore;\nconst { useMonitorStore } = monitorStore;\n\nconst Chart = styled(SimpleArea).attrs({\n  theme: 'light',\n  legendAlign: 'left',\n})``;\nexport interface WorkloadMonitoringsProps {\n  store?: string;\n}\n\nfunction Monitorings(props: WorkloadMonitoringsProps) {\n  const params: Record<string, any> = useParams();\n  const { cluster } = params;\n  const [detail] = useStore(props.store!);\n  // const {detail} = props\n  const { role = [], createTime, namespace, kind, selector } = detail?.detail ?? detail;\n  const [metrics, setMetrics] = useState<Record<string, any>>({});\n  const [pods, setPods] = useState([]);\n\n  const { data: podData } = PodsStore.useQueryList(\n    { ...PodsStore.getParams(params, kind!, selector!), limit: -1 },\n    {\n      enabled: !!detail,\n      watch: !!detail,\n    },\n  );\n\n  const { fetchMetrics } = useMonitorStore({ getApiFn: getApi });\n\n  const { mutate, isLoading } = useMutation(\n    (fecthParams: any) => {\n      const names = (podData?.data ?? []).map((pod: any) => pod.metadata.name).join('|');\n      const newParams = {\n        cluster,\n        namespace,\n        resources_filter: names,\n      };\n      if (isEmpty(pods)) {\n        return fetchSortedMetrics({\n          ...newParams,\n          sort_metrics: MetricTypes.cpu_usage,\n          limit: 5,\n          page: 1,\n        }).then((data: any) => {\n          const result = get(data[MetricTypes.cpu_usage], 'data.result') || [];\n\n          const podsParams = result.map((item: any) => get(item, 'metric.pod'));\n\n          setPods(podsParams);\n          return fetchMetrics({\n            ...newParams,\n            resources: podsParams,\n            metrics: Object.values(hideGPUByLicense(MetricTypes, cluster)),\n            fillZero: !role.includes('edge'),\n            ...fecthParams,\n          });\n        });\n      } else {\n        return fetchMetrics({\n          ...newParams,\n          resources: pods,\n          metrics: Object.values(hideGPUByLicense(MetricTypes, cluster)),\n          fillZero: !role.includes('edge'),\n          ...fecthParams,\n        });\n      }\n    },\n    {\n      onSuccess: data => {\n        setMetrics(data);\n      },\n    },\n  );\n\n  {\n    /* TODO: missing INODE_USAGE */\n  }\n  const monitoringCfgs = [\n    {\n      type: 'cpu',\n      title: 'CPU_USAGE',\n      unitType: 'cpu',\n      data: get(metrics, `${MetricTypes.cpu_usage}.data.result`, []),\n    },\n    {\n      type: 'usage',\n      title: 'MEMORY_USAGE',\n      unitType: 'memory',\n      data: get(metrics, `${MetricTypes.memory_usage}.data.result`, []),\n    },\n    {\n      type: 'gpu',\n      title: 'GPU_USAGE',\n      unitType: 'gpu',\n      data: get(metrics, `${MetricTypes.gpu_usage}.data.result`, []),\n    },\n    {\n      type: 'gpu_memory',\n      title: 'GPU_MEMORY_USAGE',\n      unitType: 'memory',\n      data: get(metrics, `${MetricTypes.gpu_memory_usage}.data.result`, []),\n    },\n    {\n      type: 'bandwidth',\n      title: 'OUTBOUND_TRAFFIC',\n      unitType: 'bandwidth',\n      data: get(metrics, `${MetricTypes.net_transmitted}.data.result`, []),\n    },\n    {\n      type: 'bandwidth',\n      title: 'INBOUND_TRAFFIC',\n      unitType: 'bandwidth',\n      data: get(metrics, `${MetricTypes.net_received}.data.result`, []),\n    },\n  ];\n\n  const configs = hideGPUByLicense(monitoringCfgs, cluster);\n\n  return (\n    <MonitorController\n      createTime={createTime}\n      onFetch={mutate}\n      loading={isLoading}\n      isEmpty={isEmpty(metrics)}\n      zIndex={1000}\n    >\n      {configs.map((item: any) => {\n        item.data = isEmpty(item.data) ? [{ values: getZeroValues() }] : item.data;\n        item.legend = item.data.map((record: any, index: number) =>\n          get(record, 'metric.pod', `pod${index}`),\n        );\n        item.workload_kind = kind;\n        const config = getAreaChartOps(item);\n\n        const height = 228 + Math.max(Math.floor(item.legend.length / 5 - 1) * 20, 0);\n\n        return (\n          <Chart\n            {...config}\n            key={`${item.title}_${item.type}`}\n            categories={kind === 'StatefulSet' ? uniq(item.legend) : item.legend}\n            height={height}\n            // showLegend={false}\n          />\n        );\n      })}\n    </MonitorController>\n  );\n}\nexport default Monitorings;\n"
      },
      {
        "path": "src/components/WorkloadKedaDetailSheet/detail.tsx",
        "content": "import {\n  BasePathParams,\n  ClusterAliasName,\n  DetailPage,\n  Events,\n  EventsSheet,\n  formatTime,\n  ProjectAliasName,\n  useCommonActions,\n  useModalAction,\n  projectNewStore,\n} from '@ks-console/shared';\nimport { Loading } from '@kubed/components';\nimport { Pen, Trash } from '@kubed/icons';\nimport * as React from 'react';\nimport store from '../../stores/autoScaling';\nimport CustomScalingStatus from '../CustomScalingStatus';\nimport { ExtensionConsoleV3Embed, triggerV3Action } from '../ExtensionConsoleV3Embed';\nimport CustomScalingSimpleStatus from '../CustomScalingSimpleStatus';\n\nconst authKey = 'ks-autoscaling';\n\ninterface WorkloadKedaDetailProps {\n  params?: BasePathParams;\n  backTo?: () => void;\n}\n\ninterface Detail {\n  status?: any;\n  createTime?: string;\n  creator?: string;\n  labels?: Record<string, string>;\n  annotations?: Record<string, string>;\n  isReady: boolean;\n}\n\nexport const WorkloadKedaDetail = (props: WorkloadKedaDetailProps) => {\n  const { params = {}, backTo } = props;\n  const { cluster, namespace, name, workspace: workspaceParams } = params;\n  const {\n    data: detail,\n    isLoading,\n    refetch,\n  } = store.useQueryDetail<Detail>({\n    cluster,\n    namespace,\n    name,\n  });\n\n  const { data: projectDetail } = projectNewStore.useQueryDetail(\n    {\n      cluster,\n      name: namespace,\n    },\n    {\n      enabled: !workspaceParams,\n    },\n  );\n\n  const workspace = workspaceParams || (projectDetail as any)?.workspace;\n  const { open } = useModalAction({\n    modal: EventsSheet,\n    id: 'auto-scaling-events',\n  });\n\n  const { editBaseInfo, editYaml, del } = useCommonActions({\n    store: store,\n    params: {\n      cluster,\n      namespace,\n    },\n    callback: (callBackType: string) => {\n      if (callBackType === 'delete') {\n        backTo?.();\n        return;\n      }\n      refetch();\n    },\n  });\n\n  const sideProps = React.useMemo(() => {\n    const base = {\n      breadcrumbs: {\n        label: t('KS_AUTOSCALING.CUSTOM_SCALING_PL'),\n        onClick: backTo,\n      },\n    };\n    if (!detail) {\n      return base;\n    }\n    const attrs = [\n      {\n        label: t('STATUS'),\n        value: (\n          <CustomScalingSimpleStatus\n            isReady={detail.isReady}\n            status={detail.status}\n            toEvent={() => {\n              open({\n                detail,\n                headerTitle: t('KS_AUTOSCALING.EVENTS'),\n              });\n            }}\n          />\n        ),\n      },\n      {\n        label: t('CLUSTER'),\n        value: <ClusterAliasName cluster={params.cluster} />,\n      },\n      {\n        label: t('PROJECT'),\n        value: <ProjectAliasName project={params.namespace} />,\n      },\n      {\n        label: t('CREATION_TIME_TCAP'),\n        value: detail?.createTime ? formatTime(detail?.createTime) : '',\n      },\n      {\n        label: t('CREATOR'),\n        value: detail.creator,\n      },\n    ];\n    const actions: any[] = [\n      {\n        key: 'edit',\n        icon: <Pen />,\n        text: t('EDIT_INFORMATION'),\n        onClick: (_: any) => {\n          const k8sVersion = globals.clusterConfig?.[cluster!]?.k8sVersion;\n          editBaseInfo(detail, k8sVersion);\n        },\n      },\n      {\n        key: 'editYaml',\n        icon: <Pen />,\n        text: t('EDIT_YAML'),\n        onClick: (_: any) => {\n          editYaml(detail);\n        },\n      },\n      {\n        key: 'editScale',\n        icon: <Pen />,\n        text: t('KS_AUTOSCALING.EDIT_SCALING_SETTINGS'),\n        onClick: (_: any) => {\n          triggerV3Action({\n            action: 'customScaling.edit.setting',\n            v3Module: 'autoScalingStore',\n            module: 'customScalings',\n            detail,\n            cluster,\n            namespace,\n            title: t('KS_AUTOSCALING.EDIT_CUSTOM_SCALING'),\n            success: () => {\n              refetch();\n            },\n          });\n        },\n      },\n      {\n        key: 'delete',\n        icon: <Trash />,\n        text: t('DELETE'),\n        onClick: (_: any) => {\n          del({ ...detail, type: 'KS_AUTOSCALING.CUSTOM_SCALING' });\n        },\n      },\n    ];\n\n    return {\n      ...base,\n      attrs,\n      actions,\n      labels: detail.labels,\n      extra: detail.annotations,\n    };\n  }, [detail]);\n\n  const [nav, setNav] = React.useState('resource-status');\n  if (isLoading) {\n    return <Loading className=\"page-loading\" />;\n  }\n  const path = `${workspace ? `/${workspace}` : ''}/clusters/${cluster}/projects/${namespace}/custom-scaling/${name}/${nav}`;\n\n  return (\n    <>\n      <DetailPage<Record<string, any>>\n        sideProps={sideProps}\n        tabs={[\n          {\n            path: `resource-status`,\n            title: t('RESOURCE_STATUS'),\n            onClick: () => {\n              setNav('resource-status');\n            },\n          },\n          {\n            path: 'events',\n            title: t('Events'),\n            onClick: () => {\n              setNav('events');\n            },\n          },\n        ]}\n        activeTab={nav}\n        store={store}\n        data={detail}\n        authKey={authKey}\n      />\n      {nav === 'resource-status' && !!workspace && (\n        <ExtensionConsoleV3Embed\n          path={path}\n          props={{\n            hideLayout: true,\n            rootMinWidth: 'unset',\n          }}\n        />\n      )}\n      {nav === 'events' && <Events detail={detail} module=\"scaledobjects\" />}\n    </>\n  );\n};\n"
      },
      {
        "path": "src/components/WorkloadKedaDetailSheet/index.styles.ts",
        "content": "import styled from 'styled-components';\n\nexport const SheetContentChildrenWrapper = styled.div`\n  display: grid;\n  grid-template-rows: 60px 1fr;\n  height: 100%;\n  .kubed-modal-title > div {\n    min-height: 40px;\n  }\n  .container-log-card {\n    width: 100%;\n    overflow: auto;\n  }\n`;\n\nexport const Content = styled.div`\n  padding: 20px;\n  background-color: ${props => props.theme.palette.accents_1};\n  height: 100%;\n  overflow: auto;\n  .detail-page-content {\n    padding: 0;\n  }\n`;\n\nexport const Overlay = styled.div<{ open?: boolean }>`\n  position: fixed;\n  inset: 0;\n  background-color: ${({ open }) => (open ? '#242e42b2' : 'transparent')};\n  z-index: 998;\n  transition: background-color 0.3s;\n`;\n"
      },
      {
        "path": "src/components/WorkloadKedaDetailSheet/index.tsx",
        "content": "import { BasePathParams, ConfigConstants } from '@ks-console/shared';\nimport { Sheet as SheetPrimitive } from '@kubed/components';\nimport * as React from 'react';\nimport { WorkloadKedaDetail } from './detail';\nimport { Content, SheetContentChildrenWrapper } from './index.styles';\nimport { Overlay } from './index.styles';\n\nconst { Sheet, SheetContent, SheetHeader, SheetFieldTitle, SheetHeaderClose } = SheetPrimitive;\n\nconst { SIDER_COLLAPSED } = ConfigConstants;\n\ninterface WorkloadKedaSheetProps extends React.ComponentProps<typeof SheetPrimitive.Sheet> {\n  params: BasePathParams;\n  detail: Record<string, any>;\n  refetch?: () => void;\n}\n\nexport const WorkloadKedaDetailSheet = (props: WorkloadKedaSheetProps) => {\n  const { open, onOpenChange, params = {}, refetch } = props;\n\n  const siderCollapsed = localStorage.getItem(SIDER_COLLAPSED);\n  const width = siderCollapsed === 'true' ? 'calc( 100vw - 60px )' : 'calc( 100vw - 220px )';\n\n  const avoidDefaultDomBehavior = (e: Event) => {\n    e.preventDefault();\n  };\n\n  const close = (state: boolean) => {\n    if (state === false) {\n      refetch?.();\n    }\n    onOpenChange?.(state);\n  };\n\n  return (\n    <>\n      <Sheet open={open} onOpenChange={close} modal={false}>\n        <SheetHeaderClose asChild>\n          <Overlay />\n        </SheetHeaderClose>\n        <SheetContent\n          hasOverlay={false}\n          width={width}\n          side={'right'}\n          onPointerDownOutside={avoidDefaultDomBehavior}\n          onInteractOutside={avoidDefaultDomBehavior}\n          // tabIndex={undefined} // To fix the issue that the input in the modal cannot get focus when the sheet is open\n        >\n          <SheetContentChildrenWrapper>\n            <SheetHeader>\n              <SheetFieldTitle title={t('KS_AUTOSCALING.CUSTOM_SCALING_PL')} />\n            </SheetHeader>\n            <Content>\n              <WorkloadKedaDetail\n                params={params}\n                backTo={() => {\n                  close(false);\n                }}\n              />\n            </Content>\n          </SheetContentChildrenWrapper>\n        </SheetContent>\n      </Sheet>\n    </>\n  );\n};\n"
      },
      {
        "path": "src/components/WorkloadKedaSheet/index.styles.ts",
        "content": "import styled from 'styled-components';\n\nexport const AlertContent = styled.div`\n  display: flex;\n  align-items: center;\n  gap: 4px;\n  & .kubed-icon {\n    color: #fff;\n    fill: #326e93;\n  }\n`;\n\nexport const SheetContentChildrenWrapper = styled.div`\n  display: grid;\n  grid-template-rows: 60px 1fr;\n  height: 100%;\n  .kubed-modal-title > div {\n    min-height: 40px;\n  }\n  .container-log-card {\n    width: 100%;\n    overflow: auto;\n  }\n`;\n\nexport const Content = styled.div`\n  padding: 16px;\n  background-color: ${props => props.theme.palette.accents_1};\n  height: 100%;\n  overflow: auto;\n`;\n\nexport const Overlay = styled.div<{ open?: boolean }>`\n  position: fixed;\n  inset: 0;\n  background-color: ${({ open }) => (open ? '#242e42b2' : 'transparent')};\n  z-index: 998;\n  transition: background-color 0.3s;\n`;\n"
      },
      {
        "path": "src/components/WorkloadKedaSheet/index.tsx",
        "content": "import { BasePathParams, ConfigConstants, FormattedWorkload } from '@ks-console/shared';\nimport { Alert, Sheet as SheetPrimitive } from '@kubed/components';\nimport { InformationDuotone } from '@kubed/icons';\nimport { get } from 'lodash';\nimport * as React from 'react';\nimport { AlertContent, Content, Overlay, SheetContentChildrenWrapper } from './index.styles';\nimport Layout from './layout';\nimport { WorkloadKedaTable } from './table';\n\nconst { Sheet, SheetContent, SheetHeader, SheetFieldTitle, SheetTitle, SheetHeaderClose } =\n  SheetPrimitive;\n\nconst { SIDER_COLLAPSED } = ConfigConstants;\n\ninterface WorkloadKedaSheetProps extends React.ComponentProps<typeof SheetPrimitive.Sheet> {\n  params: BasePathParams;\n  detail: FormattedWorkload;\n  refetch?: () => void;\n}\n\nexport const WorkloadKedaSheet = (props: WorkloadKedaSheetProps) => {\n  const { open, onOpenChange, params, detail, refetch } = props;\n\n  const siderCollapsed = localStorage.getItem(SIDER_COLLAPSED);\n  const width = siderCollapsed === 'true' ? 'calc( 100vw - 60px )' : 'calc( 100vw - 220px )';\n  const { cluster, name, namespace, workspace } = params;\n\n  const avoidDefaultDomBehavior = (e: Event) => {\n    e.preventDefault();\n  };\n\n  const close = (state: boolean) => {\n    onOpenChange?.(state);\n    if (!state) {\n      refetch?.();\n    }\n  };\n  return (\n    <Layout>\n      <>\n        <Sheet open={open} onOpenChange={close} modal={false}>\n          <SheetHeaderClose asChild>\n            <Overlay open={open} />\n          </SheetHeaderClose>\n          <SheetContent\n            width={width}\n            side={'right'}\n            hasOverlay={false}\n            onPointerDownOutside={avoidDefaultDomBehavior}\n            onInteractOutside={avoidDefaultDomBehavior}\n            // tabIndex={undefined} // To fix the issue that the input in the modal cannot get focus when the sheet is open\n          >\n            <SheetContentChildrenWrapper>\n              <SheetHeader>\n                <SheetFieldTitle title={t('KS_AUTOSCALING.CUSTOM_SCALING_PL')} />\n              </SheetHeader>\n              <Content>\n                <Alert showIcon={false} type=\"info\" style={{ marginBottom: 16 }}>\n                  <AlertContent>\n                    <InformationDuotone variant=\"light\" type=\"light\" />\n                    {t('KS_AUTOSCALING.WORKSPACE_KEDA_ALERT')}\n                  </AlertContent>\n                </Alert>\n                <WorkloadKedaTable\n                  cluster={cluster}\n                  workspace={workspace}\n                  namespace={namespace}\n                  kind={get(detail, '_originData.kind')}\n                  workloadName={name}\n                  apiVersion={get(detail, '_originData.apiVersion')}\n                />\n              </Content>\n            </SheetContentChildrenWrapper>\n          </SheetContent>\n        </Sheet>\n      </>\n    </Layout>\n  );\n};\n"
      },
      {
        "path": "src/components/WorkloadKedaSheet/layout.tsx",
        "content": "import { ModalProvider } from '@ks-console/shared';\nimport * as React from 'react';\nimport { V3ModalObserver } from '../../components/ExtensionConsoleV3Embed';\n\ninterface LayoutProps {\n  children: React.ReactElement;\n}\n\nexport default function Layout(props: LayoutProps) {\n  const { children } = props;\n  return (\n    <>\n      <ModalProvider>{children}</ModalProvider>\n      <V3ModalObserver />\n    </>\n  );\n}\n"
      },
      {
        "path": "src/components/WorkloadKedaSheet/table.tsx",
        "content": "import {\n  Avatar,\n  defaultCheckboxColumn,\n  EventsSheet,\n  getDisplayName,\n  getLocalTime,\n  joinSelector,\n  ProjectAliasName,\n  tableState2Query,\n  useBatchActions,\n  useCommonActions,\n  useItemActions,\n  useModalAction,\n  useTableActions,\n} from '@ks-console/shared';\nimport { Card, DataTable, Field } from '@kubed/components';\nimport { Pen, Stretch, Trash } from '@kubed/icons';\nimport { ColumnDef, Table } from '@tanstack/react-table';\nimport { capitalize } from 'lodash';\nimport * as React from 'react';\nimport styled from 'styled-components';\nimport store from '../../stores/autoScaling';\nimport CustomScalingStatus from '../CustomScalingStatus';\nimport { Empty } from '../Empty';\nimport { triggerV3Action } from '../ExtensionConsoleV3Embed';\nimport { WorkloadKedaDetailSheet } from '../WorkloadKedaDetailSheet';\nimport CustomScalingSimpleStatus from '../CustomScalingSimpleStatus';\n\nconst { useQueryList } = store;\nconst authKey = 'ks-autoscaling';\n\nconst Container = styled.div`\n  table .table-cell {\n    word-break: break-word;\n  }\n`;\n\nconst steps = [1, 4, 8, 16, 30];\nconst useSteps = (steps: number[]) => {\n  const [stepIndex, setStepIndex] = React.useState(0);\n  return {\n    step: steps[stepIndex],\n    nextStep: () => {\n      if (stepIndex <= steps.length - 1) {\n        setStepIndex(stepIndex + 1);\n      }\n    },\n    reset: () => {\n      setStepIndex(0);\n    },\n  };\n};\n\ninterface WorkloadKedaTableProps {\n  cluster?: string;\n  workspace?: string;\n  namespace?: string;\n  kind?: string;\n  workloadName?: string;\n  apiVersion?: string;\n}\n\ninterface Query {\n  cluster?: string;\n  namespace?: string;\n  [key: string]: string | number | boolean | undefined;\n}\n\ninterface RecordType {\n  [key: string]: any;\n}\n\nexport const WorkloadKedaTable = (props: WorkloadKedaTableProps) => {\n  const { cluster, workspace, namespace, kind, workloadName, apiVersion } = props;\n\n  const [state, setState] = React.useState<Record<string, any>>({});\n\n  const query: Query = React.useMemo(() => {\n    return {\n      cluster,\n      namespace,\n      labelSelector: joinSelector({\n        'autoscaling.kubesphere.io/scale-target-kind': kind,\n        'autoscaling.kubesphere.io/scale-target-name': workloadName,\n      }),\n      ...tableState2Query(state),\n    };\n  }, [state, cluster, namespace, kind, workloadName]);\n\n  const { step, nextStep, reset } = useSteps(steps);\n  const { data, isLoading, isFetching, isFetched, refetch } = useQueryList(query, {\n    enabled: !!cluster && !!namespace && !!kind && !!workloadName,\n    refetchInterval: step * 1000,\n    onSettled: () => {\n      nextStep();\n    },\n  });\n\n  const { open: openDetail } = useModalAction({\n    modal: WorkloadKedaDetailSheet,\n    id: 'workload-keda-detail',\n  });\n  const commonParams = () => {\n    return {\n      cluster,\n      namespace,\n    };\n  };\n\n  const { open } = useModalAction({\n    modal: EventsSheet,\n    id: 'auto-scaling-events',\n  });\n\n  const tableRef = React.useRef<Table<RecordType>>();\n\n  const { editBaseInfo, editYaml, del } = useCommonActions({\n    store: store,\n    params: {\n      cluster,\n      namespace,\n    },\n    callback: (callBackType: string) => {\n      if (callBackType === 'delete') {\n        tableRef.current?.resetRowSelection();\n        reset();\n      }\n      refetch();\n    },\n  });\n\n  const renderBatchActions = useBatchActions({\n    authKey,\n    params: {\n      cluster,\n      namespace,\n    },\n    actions: [\n      {\n        key: 'delete',\n        text: t('DELETE'),\n        onClick: () => {\n          const resource = tableRef.current?.getSelectedRowModel()?.rows.map(row => row.original!);\n          const k8sVersion = globals.clusterConfig?.[cluster!]?.k8sVersion;\n          del({ resource, type: 'KS_AUTOSCALING.CUSTOM_SCALING' }, k8sVersion);\n        },\n        props: {\n          color: 'error',\n        },\n      },\n    ],\n  });\n\n  const renderItemActions = useItemActions({\n    params: {\n      cluster,\n      namespace,\n    },\n    actions: [\n      {\n        key: 'edit',\n        icon: <Pen />,\n        text: t('EDIT_INFORMATION'),\n        onClick: (_: any, record: RecordType) => {\n          const k8sVersion = globals.clusterConfig?.[cluster!]?.k8sVersion;\n          editBaseInfo(record, k8sVersion);\n        },\n      },\n      {\n        key: 'editYaml',\n        icon: <Pen />,\n        text: t('EDIT_YAML'),\n        onClick: (_: any, record: RecordType) => {\n          editYaml(record);\n        },\n      },\n      {\n        key: 'editScale',\n        icon: <Pen />,\n        text: t('KS_AUTOSCALING.EDIT_SCALING_SETTINGS'),\n        onClick: (_: any, record: RecordType) => {\n          triggerV3Action({\n            action: 'customScaling.edit.setting',\n            v3Module: 'autoScalingStore',\n            module: 'customScalings',\n            detail: record,\n            cluster,\n            namespace,\n            title: t('KS_AUTOSCALING.EDIT_CUSTOM_SCALING'),\n            success: () => {\n              refetch();\n            },\n          });\n        },\n      },\n      {\n        key: 'delete',\n        icon: <Trash />,\n        text: t('DELETE'),\n        onClick: (_: any, record: RecordType) => {\n          del({ ...record, type: 'KS_AUTOSCALING.CUSTOM_SCALING' });\n        },\n      },\n    ],\n  });\n\n  const renderTableAction = useTableActions({\n    params: {\n      cluster,\n      namespace,\n    },\n    actions: [\n      {\n        key: 'create',\n        text: t('CREATE'),\n        props: {\n          color: 'secondary',\n          shadow: true,\n        },\n        disabled: !cluster || !namespace,\n        onClick: e => {\n          e.stopPropagation();\n          e.preventDefault();\n          triggerV3Action({\n            action: 'customScaling.create',\n            v3Module: 'autoScalingStore',\n            module: 'customScalings',\n            params: {\n              ...commonParams(),\n            },\n            cluster,\n            scaleTargetRef: {\n              apiVersion,\n              kind,\n              name: workloadName,\n            },\n            namespace,\n            title: t('KS_AUTOSCALING.CREATE_CUSTOM_SCALING'),\n            success: () => {\n              reset();\n              refetch();\n            },\n          });\n        },\n      },\n    ],\n  });\n\n  const columns = React.useMemo<ColumnDef<RecordType, any>[]>(\n    () => [\n      defaultCheckboxColumn,\n      {\n        accessorKey: 'name',\n        header: t('NAME'),\n        meta: {\n          searchKey: 'name',\n          sortable: true,\n        },\n        cell: info => {\n          return (\n            <Avatar\n              icon={<Stretch size={40} />}\n              title={\n                <a\n                  onClick={() => {\n                    const detail = info.row.original;\n                    openDetail({\n                      params: {\n                        cluster,\n                        name: detail.name,\n                        workspace,\n                        namespace,\n                      },\n                      detail,\n                      refetch,\n                    });\n                  }}\n                >\n                  {getDisplayName(info.row.original)}\n                </a>\n              }\n              description={info.row.original.description}\n            />\n          );\n        },\n      },\n      {\n        accessorKey: 'status',\n        header: t('STATUS'),\n        meta: {\n          sortable: false,\n          searchKey: 'status',\n        },\n        enableHiding: true,\n        cell: info => (\n          <CustomScalingSimpleStatus\n            isReady={info.row.original.isReady}\n            status={info.row.original.status}\n            toEvent={() => {\n              open({\n                detail: info.row.original,\n                headerTitle: t('KS_AUTOSCALING.EVENTS'),\n              });\n            }}\n          />\n        ),\n      },\n      {\n        accessorKey: 'triggers',\n        header: t('KS_AUTOSCALING.SCALER'),\n        meta: {\n          th: {\n            width: '15%',\n          },\n        },\n        enableHiding: true,\n        cell: info => {\n          const { triggers = [] } = info.row.original;\n          const triggersLabel = triggers\n            .map((item: { type?: string }) => capitalize(item.type))\n            .join(',');\n          return triggersLabel;\n        },\n      },\n      {\n        accessorKey: 'scaleTargetRef',\n        header: t('KS_AUTOSCALING.SCALING_OBJECT'),\n        meta: {\n          th: {\n            width: '15%',\n          },\n        },\n        enableHiding: true,\n        cell: info => {\n          return (\n            <Field\n              value={info.row.original.scaleTargetRef?.name ?? '-'}\n              label={info.row.original.scaleTargetRef?.kind ?? '-'}\n            />\n          );\n        },\n      },\n      {\n        accessorKey: 'minReplicaCount',\n        header: t('KS_AUTOSCALING.MINIMUM_REPLICAS'),\n        meta: {\n          th: {\n            width: '10%',\n          },\n        },\n        enableHiding: true,\n        cell: info => info.getValue() ?? '-',\n      },\n      {\n        accessorKey: 'maxReplicaCount',\n        header: t('KS_AUTOSCALING.MAXIMUM_REPLICAS'),\n        meta: {\n          th: {\n            width: '10%',\n          },\n        },\n        enableHiding: true,\n        cell: info => info.getValue() ?? '-',\n      },\n      {\n        accessorKey: 'namespace',\n        header: t('PROJECT'),\n        enableHiding: true,\n        cell: info => {\n          const value = info.getValue();\n          return <ProjectAliasName project={value} workspace={workspace} />;\n        },\n      },\n      {\n        accessorKey: 'createTime',\n        header: t('CREATION_TIME_TCAP'),\n        meta: {\n          sortable: true,\n        },\n        enableHiding: true,\n        cell: info => {\n          const time = info.getValue();\n          if (!time) {\n            return '-';\n          }\n          return getLocalTime(time).format('YYYY-MM-DD HH:mm:ss');\n        },\n      },\n      {\n        accessorKey: 'actions',\n        header: '',\n        meta: {\n          th: {\n            width: 100,\n          },\n        },\n        cell: info => renderItemActions(info.getValue(), info.row.original),\n      },\n    ],\n    [namespace],\n  );\n\n  const baseConfig = React.useState(() =>\n    DataTable.getDefaultTableOptions<RecordType>({\n      tableName: 'workspace-scaledobject-list',\n      manual: true,\n      enableVisible: true,\n      enableSelection: true,\n      enableMultiSelection: true,\n    }),\n  )[0];\n\n  const table = DataTable.useTable<RecordType>({\n    ...baseConfig,\n    columns,\n    loading: isLoading || isFetching,\n    data: data?.data ?? [],\n    rowCount: data?.total ?? 0,\n    onParamsChange: setState,\n    state,\n    getRowId: React.useCallback((row: RecordType) => row.uid, []),\n    meta: {\n      ...baseConfig.meta,\n      refetch,\n      getProps: {\n        table: () => {\n          return {\n            stickyHeader: true,\n            tableWrapperClassName: 'table',\n          };\n        },\n        toolbar: () => {\n          return {\n            batchActions: renderBatchActions(),\n            toolbarRight: renderTableAction(),\n          };\n        },\n        filters: () => {\n          return {\n            simpleMode: false,\n            suggestions: [\n              {\n                key: 'name',\n                label: t('name'),\n              },\n            ],\n          };\n        },\n        empty: () => {\n          if (!namespace) {\n            return {\n              image: <Stretch size={40} />,\n              description: t('PLEASE_SELECT_CLUSTER_OR_PROJECT'),\n            };\n          }\n          return {\n            image: <Stretch size={40} />,\n          };\n        },\n      },\n    },\n  });\n\n  React.useEffect(() => {\n    tableRef.current = table;\n  }, []);\n\n  const renderEmpty = () => {\n    return (\n      <Card padding={32}>\n        <Empty\n          icon={<Stretch size={48} />}\n          title={t('KS_AUTOSCALING.NO_CUSTOM_SCALING')}\n          desc={t('KS_AUTOSCALING.CREATE_CUSTOM_SCALING')}\n          actions={renderTableAction()}\n        />\n      </Card>\n    );\n  };\n\n  if (isFetched && (!query.page || query.page == 1) && !query.name && !data?.data?.length) {\n    return renderEmpty();\n  }\n  return (\n    <Container>\n      <Card padding={0}>\n        <DataTable.DataTable table={table} />\n      </Card>\n    </Container>\n  );\n};\n"
      },
      {
        "path": "src/components/WorkloadStatus/index.tsx",
        "content": "/*\n * Please refer to the LICENSE file in the root directory of the project.\n * https://github.com/kubesphere/console/blob/master/LICENSE\n */\n\nimport React from 'react';\nimport { TimedTask } from '@kubed/icons';\nimport { FormattedWorkload, getDeployStatus, StatusIndicator } from '@ks-console/shared';\nimport { get, isEmpty } from 'lodash';\nimport { Tooltip } from '@kubed/components';\n\nexport interface WorkloadStatusProps {\n  record: any;\n  module: string;\n}\n\nexport const S2I_STATUS_DESC: Record<string, string> = {\n  Failed: 'IMAGE_BUILDING_FAILED',\n  Running: 'BUILDING_IMAGE',\n  Successful: 'IMAGE_BUILDING_SUCCESSFUL',\n};\n\nexport const getWorkloadStatus = (record: FormattedWorkload, module: string) => {\n  const funcMap: {\n    [key: string]: any;\n  } = {\n    clonesets: getDeployStatus,\n    sidecarsets: getDeployStatus,\n  };\n\n  let status = '';\n  let reason = '';\n\n  if (funcMap[module]) {\n    status = funcMap[module](record);\n  }\n\n  if (status === 'Updating') {\n    const conditions =\n      get(record, 'status.conditions', []) ||\n      []\n        .filter((cd: { type: string; status: string }) =>\n          cd.type === 'ReplicaFailure' ? cd.status === 'True' : cd.status === 'False',\n        )\n        .reverse();\n    reason = get(conditions, '[0].reason') || '';\n  }\n\n  return { status, reason };\n};\n\nconst WorkloadStatus = ({ record, module }: WorkloadStatusProps) => {\n  const { status } = getWorkloadStatus(record, module) || '';\n\n  if (status.startsWith('S2I')) {\n    const S2iStatus: string = status.slice(4);\n\n    return (\n      <StatusIndicator type={S2iStatus as any}>{t(S2I_STATUS_DESC[S2iStatus])}</StatusIndicator>\n    );\n  }\n\n  // if (module === 'daemonsets') {\n  //   const ready = get(record, 'status.numberAvailable', 0);\n  //   const total = get(record, 'status.desiredNumberScheduled', 0);\n\n  //   return (\n  //     <StatusIndicator type={status as any} ready={ready} total={total}>\n  //       {t(status.toUpperCase())}\n  //     </StatusIndicator>\n  //   );\n  // }\n\n  return (\n    <>\n      <StatusIndicator type={status as any} ready={record.readyPodNums} total={record.podNums}>\n        {t(status.toUpperCase())}\n      </StatusIndicator>\n      {!isEmpty(get(record, 'annotations[\"kubesphere.io/relatedHPA\"]')) && (\n        <Tooltip content={t('HPA_SET_TIP')} trigger=\"hover\">\n          <TimedTask />\n        </Tooltip>\n      )}\n    </>\n  );\n};\n\nexport default WorkloadStatus;\n"
      },
      {
        "path": "src/components/useClusterProjectSelect/index.tsx",
        "content": "/*\n * Please refer to the LICENSE file in the root directory of the project.\n * https://github.com/kubesphere/console/blob/master/LICENSE\n */\n\nimport { getDisplayName, projectNewStore } from '@ks-console/shared';\nimport { Select } from '@kubed/components';\nimport { concat, debounce, first } from 'lodash';\nimport * as React from 'react';\nimport styled from 'styled-components';\n\ninterface ProjectSelectInitValue {\n  cluster?: string;\n  showDefault?: boolean;\n  showAll?: boolean;\n}\n\nconst SelectWrapper = styled(Select)`\n  .kubed-select-selector {\n    gap: 0;\n  }\n`;\n\nconst useClusterProjectSelect = (\n  initParams: ProjectSelectInitValue = {},\n  projectSelector: (d: Record<string, any>[]) => Record<string, any>[] = d => d,\n) => {\n  const { cluster, showDefault, showAll = true } = initParams;\n  const [project, setProject] = React.useState<string | undefined>('');\n  const [search, setSearch] = React.useState('');\n\n  const paramsRef = React.useRef<{\n    cluster?: string;\n    namespace?: string;\n  }>({\n    cluster,\n    namespace: project,\n  });\n\n  React.useEffect(() => {\n    paramsRef.current = {\n      namespace: project,\n      cluster,\n    };\n  }, [cluster, project]);\n\n  const {\n    data: projectList,\n    isLoading: projectLoading,\n    fetchNextPage,\n    hasNextPage,\n  } = projectNewStore.useInfiniteQueryList(\n    {\n      cluster,\n      name: search,\n      labelSelector: 'kubefed.io/managed!=true, kubesphere.io/kubefed-host-namespace!=true',\n    },\n    {\n      enabled: showAll ? true : !!cluster,\n      select: projectSelector,\n    },\n  );\n\n  const projectOptions = React.useMemo(() => {\n    const projectListDefault = (projectList ?? []).map(_project => ({\n      label: getDisplayName(_project),\n      value: _project.name,\n    }));\n\n    return showAll\n      ? concat({ label: t('ALL_PROJECTS'), value: '' }, projectListDefault)\n      : projectListDefault;\n  }, [projectList]);\n\n  const onSearch = debounce((val: string) => setSearch(val), 500);\n  const onUserScroll = (e: React.UIEvent<HTMLDivElement>) => {\n    if (!hasNextPage) {\n      return;\n    }\n    //@ts-ignore\n    const { scrollTop, scrollHeight, clientHeight } = e.target;\n    if (scrollTop + clientHeight - scrollHeight >= 0) {\n      fetchNextPage();\n    }\n  };\n\n  // select first\n  React.useEffect(() => {\n    if (!showAll) {\n      if (projectList && !project) {\n        const projects = projectList.map(item => item.name);\n        const firstCluster = first(projects);\n        setProject(firstCluster);\n      }\n    }\n  }, [projectList]);\n\n  const handleChangeProject = (value: string) => {\n    setProject(value ?? '');\n  };\n\n  const render = () => {\n    return (\n      <SelectWrapper\n        key={cluster}\n        style={{ width: 200 }}\n        showSearch\n        options={projectOptions}\n        onPopupScroll={debounce(onUserScroll, 500)}\n        onSearch={onSearch}\n        onChange={handleChangeProject}\n        loading={projectLoading}\n        value={project}\n        allowClear={showAll}\n        prefix={t('PROJECT_VALUE', { value: '' })}\n      />\n    );\n  };\n  const params = React.useMemo<{ cluster?: string; namespace?: string }>(\n    () => ({\n      cluster,\n      namespace: project,\n    }),\n    [cluster, project],\n  );\n  return {\n    params,\n    render,\n    paramsRef,\n  };\n};\n\nexport default useClusterProjectSelect;\n"
      },
      {
        "path": "src/components/useWorkspaceProjectSelect/index.tsx",
        "content": "/*\n * Please refer to the LICENSE file in the root directory of the project.\n * https://github.com/kubesphere/console/blob/master/LICENSE\n */\n\nimport { useWorkspaceProjectSelect } from '@ks-console/shared';\n\nexport default useWorkspaceProjectSelect;\n"
      },
      {
        "path": "src/constants/fluid.ts",
        "content": "export const DataSetsStatus = {\n  // Pending pending, Bound success, NotBound waiting and Failed failed\n  Pending: {\n    label: 'FLUID.Pending',\n    value: 'Pending',\n    status: 'pending',\n    color: 'warning',\n  },\n  Bound: {\n    label: 'FLUID.Bound',\n    value: 'Bound',\n    status: 'success',\n    color: 'success',\n  },\n  NotBound: {\n    label: 'FLUID.NotBound',\n    value: 'NotBound',\n    status: 'waiting',\n    color: 'default',\n  },\n  Failed: {\n    label: 'FLUID.Failed',\n    value: 'Failed',\n    status: 'failed',\n    color: 'error',\n  },\n} as const;\n\nexport const RuntimeStatus = {\n  Ready: {\n    label: 'READY',\n    value: 'Ready',\n    status: 'success',\n    color: 'success',\n  },\n  Unready: {\n    label: 'UNREADY',\n    value: 'Unready',\n    status: 'pending',\n    color: 'warning',\n  },\n  Deleting: {\n    label: 'DELETING',\n    value: 'Deleting',\n    status: 'deleting',\n    color: 'default',\n  },\n} as const;\n"
      },
      {
        "path": "src/constants/index.ts",
        "content": "const EXTENSION_NAME = 'ks-autoscaling';\n\nexport const EMBED_NAME = `${EXTENSION_NAME}-console-v3`;\n\nexport const EMBED_BASE_URL = `//${window.location.host}/${EXTENSION_NAME}/consolev3`;\n"
      },
      {
        "path": "src/constants/keda.ts",
        "content": "export const KEDA_LICENSE_QUOTA_KEY = 'count/scaledobjects.keda.sh';\n"
      },
      {
        "path": "src/constants/openkruise.ts",
        "content": "export const CloneSetStatus = {\n  running: {\n    label: 'RUNNING',\n    value: 'running',\n    status: 'running',\n    color: 'success',\n  },\n  updating: {\n    label: 'UPDATING',\n    value: 'updating',\n    status: 'updating',\n    color: 'warning',\n  },\n  stopped: {\n    label: 'STOPPED',\n    value: 'stopped',\n    status: 'stopped',\n    color: 'error',\n  },\n} as const;\n"
      },
      {
        "path": "src/events/index.tsx",
        "content": "import { EditAnnotationsModal, workspaceStore } from '@ks-console/shared';\nimport { notify } from '@kubed/components';\nimport { Pen, Stretch } from '@kubed/icons';\nimport { get, pick } from 'lodash';\nimport { default as React } from 'react';\nimport { WorkloadKedaSheet } from '../components/WorkloadKedaSheet';\n\nexport const events = {\n  // events\n  __propsMap__: {\n    'pageNav://pageNav.workspace.workloads.deployments-detail.keda': (point: any, context: any) => {\n      const keda = get(\n        context,\n        'detail._originData.metadata.labels[\"keda.autoscaling.kubesphere.io/managed\"]',\n      );\n      const hpa = get(\n        context,\n        'detail._originData.metadata.labels[\"hpa.autoscaling.kubesphere.io/managed\"]',\n      );\n      const vpa = get(\n        context,\n        'detail._originData.metadata.labels[\"vpa.autoscaling.kubesphere.io/managed\"]',\n      );\n      const enabledActions = get(context, 'enabledActions', []);\n      const show = enabledActions.includes('edit');\n      const disabled = keda !== 'true' && (hpa === 'true' || vpa === 'true');\n      return {\n        ...point,\n        disabled,\n        show,\n        icon: <Stretch size={40} />,\n      };\n    },\n  },\n  modal: {\n    'pageNav://pageNav.workspace.workloads.deployments-detail.keda': (\n      modalDispatch: any,\n      context: any,\n    ) => {\n      modalDispatch.show('open.workspace.keda', {\n        modal: WorkloadKedaSheet,\n        detail: context.detail,\n        params: pick(context.detail, ['name', 'cluster', 'namespace', 'workspace']),\n        refetch: context.refetch,\n      });\n    },\n  },\n};\n"
      },
      {
        "path": "src/index.ts",
        "content": "import { InstanceofPlugin, DocElementRectPlugin } from 'wujie-polyfill';\nimport { initWujie } from './components/ExtensionConsoleV3Embed';\nimport { events } from './events';\nimport { locales } from './locales';\nimport { menus } from './menus';\nimport { routes } from './routes';\n\nconst config = (): Record<string, any> => {\n  let plugins = [DocElementRectPlugin()];\n  const isFirefox =\n    typeof window !== 'undefined' && navigator.userAgent.toLowerCase().includes('firefox');\n  if (isFirefox) {\n    return {\n      plugins: [...plugins, InstanceofPlugin()],\n    };\n  }\n  return {\n    plugins,\n  };\n};\ninitWujie(config());\n\nexport default { routes, menus, locales, events, isCheckLicense: true };\n"
      },
      {
        "path": "src/locales/en/base.json",
        "content": "{\n  \"KS_AUTOSCALING.ELASTIC_SCALING_PL\": \"Elastic Scaling\",\n  \"KS_AUTOSCALING.NAME\": \"Name\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING_PL\": \"Event-driven Scaling\",\n  \"KS_AUTOSCALING.SCALER\": \"Scaler\",\n  \"KS_AUTOSCALING.SCALING_OBJECT\": \"Scalable object\",\n  \"KS_AUTOSCALING.MINIMUM_REPLICAS\": \"Minimum Replicas\",\n  \"KS_AUTOSCALING.EDIT_SCALING_SETTINGS\": \"Edit scaling settings\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING\": \"Event-driven Scaling\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING_LOW\": \"event-driven scaling\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING_DESC\": \"Event-driven scaling automatically scales Pods based on demand to help optimize resource usage and costs.\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING_EMPTY_DESC\": \"Please create an event-driven scaling policy.\",\n  \"KS_AUTOSCALING.MAXIMUM_REPLICAS\": \"Maximum Replicas\",\n  \"KS_AUTOSCALING.STRETCH_OBJECT_READY\": \"ScaledObject Ready\",\n  \"KS_AUTOSCALING.STRETCH_OBJECT_READY_DESC\": \"Whether the scalable object is ready to start scaling\",\n  \"KS_AUTOSCALING.TRIGGER_ACTIVE\": \"Active Triggers\",\n  \"KS_AUTOSCALING.TRIGGER_ACTIVE_DESC\": \"Whether scaling is occurring on the scalable object\",\n  \"KS_AUTOSCALING.RETRACTOR_FALLBACK\": \"Scaler Rollback\",\n  \"KS_AUTOSCALING.RETRACTOR_FALLBACK_DESC\": \"Whether the scaler is able to obtain metrics from the source\",\n  \"KS_AUTOSCALING.RETRACTOR_PAUSE_DESC\": \"Whether scaling is paused\",\n  \"KS_AUTOSCALING.PAUSE\": \"Pause\",\n  \"KS_AUTOSCALING.EVENTS\": \"Events\",\n  \"KS_AUTOSCALING.STATUS_INFORMATION\": \"Status Information\",\n  \"KS_AUTOSCALING.STATUS_VALUE\": \"Status: {value}\",\n  \"KS_AUTOSCALING.REASON_VALUE\": \"Reason: {value}\",\n  \"KS_AUTOSCALING.MESSAGE_VALUE\": \"Message: {value}\",\n  \"KS_AUTOSCALING.WORKSPACE_KEDA_ALERT\": \"Only show event-driven scaling strategies that are bound to the current workload resource.\",\n  \"KS_AUTOSCALING.NO_CUSTOM_SCALING\": \"No event-driven scaling strategies found.\",\n  \"KS_AUTOSCALING.CREATE_CUSTOM_SCALING\": \"Create event-driven scaling\",\n  \"KS_AUTOSCALING.EDIT_CUSTOM_SCALING\": \"Edit event-driven scaling\",\n  \"KS_AUTOSCALING.SCALING_SETTINGS\": \"Scaling Settings\",\n  \"KS_AUTOSCALING.NORMAL\": \"Normal\",\n  \"KS_AUTOSCALING.ABNORMAL\": \"Abnormal\",\n  \"KS_AUTOSCALING.CREATING\": \"Creating\"\n}\n"
      },
      {
        "path": "src/locales/en/index.js",
        "content": "import base from './base.json';\n\nexport default { ...base };\n"
      },
      {
        "path": "src/locales/es/base.json",
        "content": "{\n  \"KS_AUTOSCALING.ELASTIC_SCALING_PL\": \"Escalado elstico\",\n  \"KS_AUTOSCALING.NAME\": \"Nombre\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING_PL\": \"Escalado basado en eventos\",\n  \"KS_AUTOSCALING.SCALER\": \"Escalador\",\n  \"KS_AUTOSCALING.SCALING_OBJECT\": \"Objeto escalable\",\n  \"KS_AUTOSCALING.MINIMUM_REPLICAS\": \"Rplicas mnimas\",\n  \"KS_AUTOSCALING.EDIT_SCALING_SETTINGS\": \"Editar configuracin de escalado\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING\": \"Escalado basado en eventos\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING_LOW\": \"escalado basado en eventos\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING_DESC\": \"El escalado basado en eventos escala automticamente los Pods segn la demanda para ayudar a optimizar el uso de recursos y los costos.\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING_EMPTY_DESC\": \"Por favor, cree una poltica de escalado basada en eventos.\",\n  \"KS_AUTOSCALING.MAXIMUM_REPLICAS\": \"Rplicas mximas\",\n  \"KS_AUTOSCALING.STRETCH_OBJECT_READY\": \"Objeto escalado listo\",\n  \"KS_AUTOSCALING.STRETCH_OBJECT_READY_DESC\": \"Si el objeto escalable est listo para comenzar a escalar\",\n  \"KS_AUTOSCALING.TRIGGER_ACTIVE\": \"Disparadores activos\",\n  \"KS_AUTOSCALING.TRIGGER_ACTIVE_DESC\": \"Si se est produciendo el escalado en el objeto escalable\",\n  \"KS_AUTOSCALING.RETRACTOR_FALLBACK\": \"Escalador de reversin\",\n  \"KS_AUTOSCALING.RETRACTOR_FALLBACK_DESC\": \"Si el escalador puede obtener mtricas de la fuente\",\n  \"KS_AUTOSCALING.RETRACTOR_PAUSE_DESC\": \"Si el escalado est pausado\",\n  \"KS_AUTOSCALING.PAUSE\": \"Pausar\",\n  \"KS_AUTOSCALING.EVENTS\": \"Eventos\",\n  \"KS_AUTOSCALING.STATUS_INFORMATION\": \"Informacin de estado\",\n  \"KS_AUTOSCALING.STATUS_VALUE\": \"Estado: {value}\",\n  \"KS_AUTOSCALING.REASON_VALUE\": \"Razn: {value}\",\n  \"KS_AUTOSCALING.MESSAGE_VALUE\": \"Mensaje: {value}\",\n  \"KS_AUTOSCALING.WORKSPACE_KEDA_ALERT\": \"Solo mostrar estrategias de escalado basadas en eventos que estn vinculadas al recurso de carga de trabajo actual.\",\n  \"KS_AUTOSCALING.NO_CUSTOM_SCALING\": \"No se encontraron estrategias de escalado basadas en eventos.\",\n  \"KS_AUTOSCALING.CREATE_CUSTOM_SCALING\": \"Crear escalado basado en eventos\",\n  \"KS_AUTOSCALING.EDIT_CUSTOM_SCALING\": \"Editar escalado basado en eventos\",\n  \"KS_AUTOSCALING.SCALING_SETTINGS\": \"Configuracin de escalado\",\n  \"KS_AUTOSCALING.NORMAL\": \"Normal\",\n  \"KS_AUTOSCALING.ABNORMAL\": \"Anormal\",\n  \"KS_AUTOSCALING.CREATING\": \"Creando\"\n}\n"
      },
      {
        "path": "src/locales/es/index.js",
        "content": "import base from './base.json';\n\nexport default { ...base };\n"
      },
      {
        "path": "src/locales/index.js",
        "content": "import zh from './zh';\nimport en from './en';\nimport es from './es';\nimport tc from './tc';\n\nexport const locales = { zh, en, es, tc };\n"
      },
      {
        "path": "src/locales/tc/base.json",
        "content": "{\n  \"KS_AUTOSCALING.ELASTIC_SCALING_PL\": \"\",\n  \"KS_AUTOSCALING.NAME\": \"\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING_PL\": \"\",\n  \"KS_AUTOSCALING.SCALER\": \"\",\n  \"KS_AUTOSCALING.SCALING_OBJECT\": \"\",\n  \"KS_AUTOSCALING.MINIMUM_REPLICAS\": \"\",\n  \"KS_AUTOSCALING.EDIT_SCALING_SETTINGS\": \"\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING\": \"\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING_LOW\": \"\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING_DESC\": \" Pod \",\n  \"KS_AUTOSCALING.CUSTOM_SCALING_EMPTY_DESC\": \"\",\n  \"KS_AUTOSCALING.MAXIMUM_REPLICAS\": \"\",\n  \"KS_AUTOSCALING.STRETCH_OBJECT_READY\": \"\",\n  \"KS_AUTOSCALING.STRETCH_OBJECT_READY_DESC\": \"\",\n  \"KS_AUTOSCALING.TRIGGER_ACTIVE\": \"\",\n  \"KS_AUTOSCALING.TRIGGER_ACTIVE_DESC\": \"\",\n  \"KS_AUTOSCALING.RETRACTOR_FALLBACK\": \"\",\n  \"KS_AUTOSCALING.RETRACTOR_FALLBACK_DESC\": \"\",\n  \"KS_AUTOSCALING.RETRACTOR_PAUSE_DESC\": \"\",\n  \"KS_AUTOSCALING.PAUSE\": \"\",\n  \"KS_AUTOSCALING.EVENTS\": \"\",\n  \"KS_AUTOSCALING.STATUS_INFORMATION\": \"\",\n  \"KS_AUTOSCALING.STATUS_VALUE\": \"{value}\",\n  \"KS_AUTOSCALING.REASON_VALUE\": \"{value}\",\n  \"KS_AUTOSCALING.MESSAGE_VALUE\": \"{value}\",\n  \"KS_AUTOSCALING.WORKSPACE_KEDA_ALERT\": \"\",\n  \"KS_AUTOSCALING.NO_CUSTOM_SCALING\": \"\",\n  \"KS_AUTOSCALING.CREATE_CUSTOM_SCALING\": \"\",\n  \"KS_AUTOSCALING.EDIT_CUSTOM_SCALING\": \"\",\n  \"KS_AUTOSCALING.SCALING_SETTINGS\": \"\",\n  \"KS_AUTOSCALING.NORMAL\": \"\",\n  \"KS_AUTOSCALING.ABNORMAL\": \"\",\n  \"KS_AUTOSCALING.CREATING\": \"\"\n}\n"
      },
      {
        "path": "src/locales/tc/index.js",
        "content": "import base from './base.json';\n\nexport default { ...base };\n"
      },
      {
        "path": "src/locales/zh/base.json",
        "content": "{\n  \"KS_AUTOSCALING.ELASTIC_SCALING_PL\": \"\",\n  \"KS_AUTOSCALING.NAME\": \"\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING_PL\": \"\",\n  \"KS_AUTOSCALING.SCALER\": \"\",\n  \"KS_AUTOSCALING.SCALING_OBJECT\": \"\",\n  \"KS_AUTOSCALING.MINIMUM_REPLICAS\": \"\",\n  \"KS_AUTOSCALING.EDIT_SCALING_SETTINGS\": \"\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING\": \"\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING_LOW\": \"\",\n  \"KS_AUTOSCALING.CUSTOM_SCALING_DESC\": \" Pod \",\n  \"KS_AUTOSCALING.CUSTOM_SCALING_EMPTY_DESC\": \"\",\n  \"KS_AUTOSCALING.MAXIMUM_REPLICAS\": \"\",\n  \"KS_AUTOSCALING.STRETCH_OBJECT_READY\": \"\",\n  \"KS_AUTOSCALING.STRETCH_OBJECT_READY_DESC\": \"\",\n  \"KS_AUTOSCALING.TRIGGER_ACTIVE\": \"\",\n  \"KS_AUTOSCALING.TRIGGER_ACTIVE_DESC\": \"\",\n  \"KS_AUTOSCALING.RETRACTOR_FALLBACK\": \"\",\n  \"KS_AUTOSCALING.RETRACTOR_FALLBACK_DESC\": \"\",\n  \"KS_AUTOSCALING.RETRACTOR_PAUSE_DESC\": \"\",\n  \"KS_AUTOSCALING.PAUSE\": \"\",\n  \"KS_AUTOSCALING.EVENTS\": \"\",\n  \"KS_AUTOSCALING.STATUS_INFORMATION\": \"\",\n  \"KS_AUTOSCALING.STATUS_VALUE\": \"{value}\",\n  \"KS_AUTOSCALING.REASON_VALUE\": \"{value}\",\n  \"KS_AUTOSCALING.MESSAGE_VALUE\": \"{value}\",\n  \"KS_AUTOSCALING.WORKSPACE_KEDA_ALERT\": \"\",\n  \"KS_AUTOSCALING.NO_CUSTOM_SCALING\": \"\",\n  \"KS_AUTOSCALING.CREATE_CUSTOM_SCALING\": \"\",\n  \"KS_AUTOSCALING.EDIT_CUSTOM_SCALING\": \"\",\n  \"KS_AUTOSCALING.SCALING_SETTINGS\": \"\",\n  \"KS_AUTOSCALING.NORMAL\": \"\",\n  \"KS_AUTOSCALING.ABNORMAL\": \"\",\n  \"KS_AUTOSCALING.CREATING\": \"\"\n}\n"
      },
      {
        "path": "src/locales/zh/index.js",
        "content": "import base from './base.json';\n\nexport default { ...base };\n"
      },
      {
        "path": "src/menus/index.ts",
        "content": "import kedaMenus from './keda';\n\nexport const menus = [\n  ...kedaMenus,\n];\n"
      },
      {
        "path": "src/menus/keda.ts",
        "content": "export default [\n  {\n    parent: 'cluster',\n    name: 'elastic_scaling',\n    title: 'KS_AUTOSCALING.ELASTIC_SCALING_PL',\n    icon: 'stretch',\n    order: 4,\n    skipIfExist: true,\n  },\n  {\n    parent: 'cluster.elastic_scaling',\n    name: 'custom-scaling',\n    title: 'KS_AUTOSCALING.CUSTOM_SCALING_PL',\n    icon: 'stretch',\n    clusterModule: 'ks-autoscaling',\n    skipWorkspaceAuth: true,\n  },\n  {\n    parent: 'workspace',\n    name: 'elastic_scaling',\n    extensionName: 'ks-autoscaling',\n    title: 'KS_AUTOSCALING.ELASTIC_SCALING_PL',\n    icon: 'stretch',\n    order: 2,\n    skipIfExist: true,\n  },\n  {\n    parent: 'workspace.elastic_scaling',\n    name: 'custom-scaling',\n    \n    title: 'KS_AUTOSCALING.CUSTOM_SCALING_PL',\n    icon: 'stretch',\n    ksModule: 'ks-autoscaling',\n    workspaceModule: 'ks-autoscaling',\n    skipWorkspaceAuth: true,\n  },\n  {\n    parent: 'pageNav.workspace.workloads.deployments-detail',\n    name: 'keda',\n    icon: 'stretch',\n    clusterModule: 'ks-autoscaling',\n    title: 'KS_AUTOSCALING.CUSTOM_SCALING_PL',\n    order: 5,\n    actionType: 'modal',\n    actionValue: 'pageNav://pageNav.workspace.workloads.deployments-detail.keda',\n  },\n  {\n    parent: 'pageNav.workspace.workloads.statefulsets-detail',\n    name: 'keda',\n    icon: 'stretch',\n    clusterModule: 'ks-autoscaling',\n    title: 'KS_AUTOSCALING.CUSTOM_SCALING_PL',\n    order: 5,\n    actionType: 'modal',\n    actionValue: 'pageNav://pageNav.workspace.workloads.deployments-detail.keda',\n  },\n  {\n    parent: 'pageNav.cluster.deployments.detail',\n    name: 'keda',\n    icon: 'stretch',\n    clusterModule: 'ks-autoscaling',\n    title: 'KS_AUTOSCALING.CUSTOM_SCALING_PL',\n    order: 5,\n    actionType: 'modal',\n    actionValue: 'pageNav://pageNav.workspace.workloads.deployments-detail.keda',\n  },\n  {\n    parent: 'pageNav.cluster.statefulsets.detail',\n    name: 'keda',\n    icon: 'stretch',\n    clusterModule: 'ks-autoscaling',\n    title: 'KS_AUTOSCALING.CUSTOM_SCALING_PL',\n    order: 5,\n    actionType: 'modal',\n    actionValue: 'pageNav://pageNav.workspace.workloads.deployments-detail.keda',\n  },\n];\n"
      },
      {
        "path": "src/pages/clusters/CustomScaling/Detail/Events.tsx",
        "content": "/*\n * Please refer to the LICENSE file in the root directory of the project.\n * https://github.com/kubesphere/console/blob/master/LICENSE\n */\n\nimport React from 'react';\nimport { Events, useDetailPage } from '@ks-console/shared';\n\nexport default function DetailMetaData() {\n  const { detail } = useDetailPage<Record<string, any>>();\n  return <Events detail={detail} module={'scaledobjects'} />;\n}\n"
      },
      {
        "path": "src/pages/clusters/CustomScaling/Detail/ResourceStatus.tsx",
        "content": "import React from 'react';\n\nimport { BasePathParams, useDetailPage } from '@ks-console/shared';\nimport { useParams } from 'react-router-dom';\nimport { ExtensionConsoleV3Embed } from '../../../../components/ExtensionConsoleV3Embed';\nimport ScalingStatus, { KedaDetail } from './ScalingStatus/index';\n\nexport default function Embed() {\n  const { workspace, cluster, namespace, name } = useParams<BasePathParams>();\n  const { detail } = useDetailPage();\n  const path = workspace\n    ? `/${workspace}/clusters/${cluster}/projects/${namespace}/custom-scaling/${name}/resource-status`\n    : `/clusters/${cluster}/projects/${namespace}/custom-scaling/${name}/resource-status`;\n  return (\n    <div>\n      <ScalingStatus detail={detail as KedaDetail} />\n      <ExtensionConsoleV3Embed\n        path={path}\n        props={{\n          hideLayout: true,\n          rootMinWidth: 'unset',\n        }}\n      />\n    </div>\n  );\n}\n"
      },
      {
        "path": "src/pages/clusters/CustomScaling/Detail/ScalingStatus/index.tsx",
        "content": "/*\n * Please refer to the LICENSE file in the root directory of the project.\n * https://github.com/kubesphere/console/blob/master/LICENSE\n */\n\nimport React, { memo } from 'react';\nimport { Card as Panel, Tooltip, Field } from '@kubed/components';\nimport { Icon } from '@ks-console/shared';\nimport styled from 'styled-components';\n\nconst ICON_TYPES = {\n  False: { name: 'failure', color: '#AB2F29' },\n  True: { name: 'success', color: '#55BC8A' },\n  Unknown: { name: 'question', color: '#E0992C' },\n  Paused: { name: 'pause', color: '#E0992C' },\n};\n\nconst STATUS_TITLE = {\n  Ready: 'KS_AUTOSCALING.STRETCH_OBJECT_READY',\n  Active: 'KS_AUTOSCALING.TRIGGER_ACTIVE',\n  Fallback: 'KS_AUTOSCALING.RETRACTOR_FALLBACK',\n  Paused: 'KS_AUTOSCALING.PAUSE',\n};\n\n// Styled Components\nconst ScalingObjectContainer = styled.div`\n  display: grid;\n  grid-template-columns: repeat(4, minmax(0, 1fr));\n  gap: 12px;\n`;\n\nconst ItemBoxBodyItem = styled.div`\n  position: relative;\n  width: 100%;\n  padding: 12px;\n  background: #f9fbfd;\n  border-radius: 4px;\n`;\n\nconst ItemMoreMessage = styled.span`\n  position: absolute;\n  bottom: 12px;\n  left: 36px;\n  height: 16px;\n  width: 16px;\n`;\n\nconst TooltipContent = styled.div`\n  min-width: 264px;\n  & li {\n    color: #abb4be;\n  }\n`;\n\nconst TooltipTitle = styled.p`\n  font-weight: 600;\n  color: #fff;\n  margin: 0;\n`;\n\n// Types\ninterface Condition {\n  type: keyof typeof STATUS_TITLE;\n  status: keyof typeof ICON_TYPES;\n  reason?: string;\n  message?: string;\n}\n\ninterface DetailStatus {\n  conditions?: Condition[];\n}\n\nexport interface KedaDetail {\n  status?: DetailStatus;\n}\n\ninterface ScalingStatusProps {\n  detail: KedaDetail;\n}\n\ninterface DataMapperItem {\n  icon: string;\n  title: string;\n  desc: string;\n  type: keyof typeof STATUS_TITLE;\n}\n\nconst ScalingStatus: React.FC<ScalingStatusProps> = ({ detail }) => {\n  const conditions = detail?.status?.conditions ?? [];\n\n  const data_mapper: DataMapperItem[] = [\n    {\n      icon: 'target',\n      title: t('KS_AUTOSCALING.STRETCH_OBJECT_READY'),\n      desc: t('KS_AUTOSCALING.STRETCH_OBJECT_READY_DESC'),\n      type: 'Ready',\n    },\n    {\n      icon: 'stretch',\n      title: t('KS_AUTOSCALING.TRIGGER_ACTIVE'),\n      desc: t('KS_AUTOSCALING.TRIGGER_ACTIVE_DESC'),\n      type: 'Active',\n    },\n    {\n      icon: 'TimedTask',\n      title: t('KS_AUTOSCALING.RETRACTOR_FALLBACK'),\n      desc: t('KS_AUTOSCALING.RETRACTOR_FALLBACK_DESC'),\n      type: 'Fallback',\n    },\n    {\n      icon: 'PauseCircleDuotone',\n      title: t('KS_AUTOSCALING.PAUSE'),\n      desc: t('KS_AUTOSCALING.RETRACTOR_PAUSE_DESC'),\n      type: 'Paused',\n    },\n  ];\n\n  const renderToolTipContent = (item: Condition) => {\n    return (\n      <TooltipContent>\n        <TooltipTitle>{t(STATUS_TITLE[item.type])}</TooltipTitle>\n        <ul>\n          <li>{t('KS_AUTOSCALING.STATUS_VALUE', { value: item.status })}</li>\n          <li>{item.reason && t('KS_AUTOSCALING.REASON_VALUE', { value: item.reason })}</li>\n          <li>{item.message && t('KS_AUTOSCALING.MESSAGE_VALUE', { value: item.message })}</li>\n        </ul>\n      </TooltipContent>\n    );\n  };\n\n  const renderScalingStatus = (_item: DataMapperItem) => {\n    const condition = conditions.find(item => item.type === _item.type);\n    if (!condition) {\n      return null;\n    }\n    const name = !condition?.status ? 'success' : (ICON_TYPES[condition.status]?.name ?? 'success');\n    const iconColor = ICON_TYPES[condition.status]?.color ?? '#55BC8A';\n\n    return (\n      <Tooltip maxWidth={300} content={renderToolTipContent(condition)}>\n        <Icon\n          size={16}\n          name={name}\n          style={{\n            color: '#fff',\n            fill: iconColor,\n          }}\n        />\n      </Tooltip>\n    );\n  };\n\n  return (\n    <Panel className=\"mb12\" sectionTitle={t('KS_AUTOSCALING.STATUS_INFORMATION')}>\n      <ScalingObjectContainer>\n        {data_mapper.map((_item, index) => (\n          <ItemBoxBodyItem key={index}>\n            <Field\n              avatar={<Icon name={_item.icon} size={40} />}\n              value={_item.title}\n              label={_item.desc || '-'}\n            />\n            <ItemMoreMessage>{renderScalingStatus(_item)}</ItemMoreMessage>\n          </ItemBoxBodyItem>\n        ))}\n      </ScalingObjectContainer>\n    </Panel>\n  );\n};\n\nexport default memo(ScalingStatus);\n"
      },
      {
        "path": "src/pages/clusters/CustomScaling/Detail/index.tsx",
        "content": "import {\n  BasePathParams,\n  ClusterAliasName,\n  DetailPage,\n  Events,\n  EventsSheet,\n  formatTime,\n  ProjectAliasName,\n  useCommonActions,\n  useModalAction,\n  projectNewStore,\n} from '@ks-console/shared';\nimport { Loading } from '@kubed/components';\nimport { Pen, Trash } from '@kubed/icons';\nimport * as React from 'react';\nimport store from '../../../../stores/autoScaling';\nimport CustomScalingSimpleStatus from '../../../../components/CustomScalingSimpleStatus';\nimport { triggerV3Action } from '../../../../components/ExtensionConsoleV3Embed';\nimport { useNavigate, useParams } from 'react-router-dom';\n\nconst authKey = 'ks-autoscaling';\n\ninterface WorkloadKedaDetailProps {\n  params?: BasePathParams;\n  backTo?: () => void;\n}\n\ninterface Detail {\n  status?: any;\n  createTime?: string;\n  creator?: string;\n  labels?: Record<string, string>;\n  annotations?: Record<string, string>;\n  isReady: boolean;\n}\n\nconst WorkloadKedaDetail = (props: WorkloadKedaDetailProps) => {\n  const params = useParams<BasePathParams>();\n  const navigate = useNavigate();\n  const { cluster, namespace, name, workspace: workspaceParams } = params;\n  const {\n    data: detail,\n    isLoading,\n    refetch,\n  } = store.useQueryDetail<Detail>({\n    cluster,\n    namespace,\n    name,\n  });\n\n  const url = workspaceParams\n    ? `/workspaces/${workspaceParams}/custom-scaling`\n    : `/clusters/${cluster}/custom-scaling`;\n\n  const backTo = () => {\n    navigate(url);\n  };\n\n  const { data: projectDetail } = projectNewStore.useQueryDetail(\n    {\n      cluster,\n      name: namespace,\n    },\n    {\n      enabled: !workspaceParams,\n    },\n  );\n\n  const workspace = workspaceParams || (projectDetail as any)?.workspace;\n  const { open } = useModalAction({\n    modal: EventsSheet,\n    id: 'auto-scaling-events',\n  });\n\n  const { editBaseInfo, editYaml, del } = useCommonActions({\n    store: store,\n    params: {\n      cluster,\n      namespace,\n    },\n    callback: (callBackType: string) => {\n      if (callBackType === 'delete') {\n        backTo?.();\n        return;\n      }\n      refetch();\n    },\n  });\n\n  const sideProps = React.useMemo(() => {\n    const base = {\n      breadcrumbs: {\n        label: t('KS_AUTOSCALING.CUSTOM_SCALING_PL'),\n        // onClick: backTo,\n        url,\n      },\n    };\n    if (!detail) {\n      return base;\n    }\n    const attrs = [\n      {\n        label: t('STATUS'),\n        value: (\n          <CustomScalingSimpleStatus\n            isReady={detail.isReady}\n            status={detail.status}\n            toEvent={() => {\n              open({\n                detail,\n                headerTitle: t('KS_AUTOSCALING.EVENTS'),\n              });\n            }}\n          />\n        ),\n      },\n      {\n        label: t('CLUSTER'),\n        value: <ClusterAliasName cluster={params.cluster} />,\n      },\n      {\n        label: t('PROJECT'),\n        value: <ProjectAliasName project={params.namespace} />,\n      },\n      {\n        label: t('CREATION_TIME_TCAP'),\n        value: detail?.createTime ? formatTime(detail?.createTime) : '',\n      },\n      {\n        label: t('CREATOR'),\n        value: detail.creator,\n      },\n    ];\n    const actions: any[] = [\n      {\n        key: 'edit',\n        icon: <Pen />,\n        text: t('EDIT_INFORMATION'),\n        onClick: (_: any) => {\n          const k8sVersion = globals.clusterConfig?.[cluster!]?.k8sVersion;\n          editBaseInfo(detail, k8sVersion);\n        },\n      },\n      {\n        key: 'editYaml',\n        icon: <Pen />,\n        text: t('EDIT_YAML'),\n        onClick: (_: any) => {\n          editYaml(detail);\n        },\n      },\n      {\n        key: 'editScale',\n        icon: <Pen />,\n        text: t('KS_AUTOSCALING.EDIT_SCALING_SETTINGS'),\n        onClick: (_: any) => {\n          triggerV3Action({\n            action: 'customScaling.edit.setting',\n            v3Module: 'autoScalingStore',\n            module: 'customScalings',\n            detail,\n            cluster,\n            namespace,\n            title: t('KS_AUTOSCALING.EDIT_CUSTOM_SCALING'),\n            success: () => {\n              refetch();\n            },\n          });\n        },\n      },\n      {\n        key: 'delete',\n        icon: <Trash />,\n        text: t('DELETE'),\n        onClick: (_: any) => {\n          del({ ...detail, type: 'KS_AUTOSCALING.CUSTOM_SCALING' });\n        },\n      },\n    ];\n\n    return {\n      ...base,\n      attrs,\n      actions,\n      labels: detail.labels,\n      extra: detail.annotations,\n    };\n  }, [detail]);\n\n  if (isLoading) {\n    return <Loading className=\"page-loading\" />;\n  }\n\n  return (\n    <>\n      <DetailPage<Record<string, any>>\n        sideProps={sideProps}\n        tabs={[\n          {\n            path: `resource-status`,\n            title: t('RESOURCE_STATUS'),\n          },\n          {\n            path: 'events',\n            title: t('Events'),\n          },\n        ]}\n        store={store}\n        data={detail}\n        authKey={authKey}\n      />\n    </>\n  );\n};\n\nexport default WorkloadKedaDetail;\n"
      },
      {
        "path": "src/pages/clusters/CustomScaling/index.styles.ts",
        "content": "import styled from 'styled-components';\n\nexport const Container = styled.div`\n  table .table-cell {\n    word-break: break-word;\n  }\n`;\n"
      },
      {
        "path": "src/pages/clusters/CustomScaling/index.tsx",
        "content": "import {\n  Avatar,\n  BasePathParams,\n  defaultCheckboxColumn,\n  EventsSheet,\n  FormattedCluster,\n  getDisplayName,\n  getLocalTime,\n  hasClusterModule,\n  joinSelector,\n  PageLayout,\n  tableState2Query,\n  useBatchActions,\n  useCommonActions,\n  useItemActions,\n  useModalAction,\n  useTableActions,\n  useUrlSearchParamsStatus,\n} from '@ks-console/shared';\nimport { Card, DataTable, Field } from '@kubed/components';\nimport { Pen, Stretch, Trash } from '@kubed/icons';\nimport { ColumnDef, Table } from '@tanstack/react-table';\nimport { capitalize } from 'lodash';\nimport * as React from 'react';\nimport { Link, useParams } from 'react-router-dom';\nimport { triggerV3Action } from '../../../components/ExtensionConsoleV3Embed';\nimport useWorkspaceClusterSelect from '../../../components/useWorkspaceProjectSelect';\nimport store from '../../../stores/autoScaling';\nimport { Container } from './index.styles';\nimport CustomScalingStatus from '../../../components/CustomScalingStatus';\nimport CustomScalingSimpleStatus from '../../../components/CustomScalingSimpleStatus';\nimport useClusterProjectSelect from '../../../components/useClusterProjectSelect';\nimport { KEDA_LICENSE_QUOTA_KEY } from './../../../constants/keda';\n\nconst { useQueryList } = store;\nconst authKey = 'autoscaling';\n\nconst steps = [1, 4, 16, 30];\nconst useSteps = (steps: number[]) => {\n  const [stepIndex, setStepIndex] = React.useState(0);\n  return {\n    step: steps[stepIndex],\n    nextStep: () => {\n      if (stepIndex <= steps.length - 1) {\n        setStepIndex(stepIndex + 1);\n      }\n    },\n    reset: () => {\n      setStepIndex(0);\n    },\n  };\n};\n\nconst KIND_MODULE: { [key: string]: string } = {\n  Deployment: 'deployments',\n  StatefulSet: 'statefulsets',\n  DaemonSet: 'daemonsets',\n  Pod: 'pods',\n  deployment: 'deployments',\n  statefulset: 'statefulsets',\n  daemonset: 'daemonsets',\n  pod: 'pods',\n};\n\nconst CustomScaling = () => {\n  const { cluster } = useParams<BasePathParams>();\n  const {\n    paramsRef,\n    params: namespaceParams,\n    render: renderSelect,\n  } = useClusterProjectSelect({ cluster });\n\n  const { namespace } = namespaceParams;\n  const { state, setState } = useUrlSearchParamsStatus([]);\n\n  const query = React.useMemo(() => {\n    const { status, ...tableQuery } = tableState2Query(state);\n    const statusQuery = {\n      fieldSelector: undefined as string | undefined,\n    };\n    if (status === 'normal') {\n      statusQuery.fieldSelector = joinSelector({\n        'metadata.annotations.keda\\\\.autoscaling\\\\.kubesphere\\\\.io/ready': 'true',\n      });\n    } else if (status === 'abnormal') {\n      statusQuery.fieldSelector = joinSelector({\n        'metadata.annotations.keda\\\\.autoscaling\\\\.kubesphere\\\\.io/ready': 'false',\n      });\n    } else if (status === 'creating') {\n      statusQuery.fieldSelector = joinSelector({\n        'metadata.annotations.keda\\\\.autoscaling\\\\.kubesphere\\\\.io/ready': 'unknown',\n      });\n    }\n    return {\n      ...tableQuery,\n      ...statusQuery,\n      ...namespaceParams,\n    };\n  }, [state, namespaceParams]);\n\n  const { step, nextStep, reset } = useSteps(steps);\n  const { data, isLoading, isFetching, refetch } = useQueryList(query, {\n    refetchInterval: step * 1000,\n    onSettled: () => {\n      nextStep();\n    },\n  });\n  const commonParams = () => {\n    return {\n      cluster: paramsRef.current.cluster,\n      namespace: paramsRef.current.namespace,\n    };\n  };\n\n  // const callback = () => refetch();\n\n  const { open } = useModalAction({\n    modal: EventsSheet,\n    id: 'auto-scaling-events',\n  });\n\n  const tableRef = React.useRef<Table<Record<string, any>>>();\n\n  const { editBaseInfo, editYaml, del } = useCommonActions({\n    store: store,\n    params: {\n      cluster: paramsRef.current.cluster,\n    },\n    callback: callBackType => {\n      if (callBackType === 'delete') {\n        tableRef.current?.resetRowSelection();\n        reset();\n      }\n      refetch();\n    },\n  });\n\n  const renderBatchActions = useBatchActions({\n    authKey,\n    params: namespaceParams,\n    actions: [\n      {\n        key: 'delete',\n        text: t('DELETE'),\n        action: 'delete',\n        onClick: () => {\n          const resource = tableRef.current?.getSelectedRowModel()?.rows.map(row => row.original!);\n          const k8sVersion = globals.clusterConfig?.[paramsRef.current.cluster!]?.k8sVersion;\n          del({ resource, type: 'KS_AUTOSCALING.CUSTOM_SCALING' }, k8sVersion);\n        },\n        props: {\n          color: 'error',\n        },\n      },\n    ],\n  });\n\n  const renderItemActions = useItemActions({\n    authKey,\n    params: namespaceParams,\n    actions: [\n      {\n        key: 'edit',\n        icon: <Pen />,\n        text: t('EDIT_INFORMATION'),\n        action: 'edit',\n        onClick: (_, record) => {\n          const k8sVersion = globals.clusterConfig?.[paramsRef.current.cluster!]?.k8sVersion;\n          editBaseInfo(record, k8sVersion);\n        },\n      },\n      {\n        key: 'editYaml',\n        icon: <Pen />,\n        text: t('EDIT_YAML'),\n        action: 'edit',\n        onClick: (_, record) => {\n          editYaml(record);\n        },\n      },\n      {\n        key: 'editScale',\n        icon: <Pen />,\n        text: t('KS_AUTOSCALING.EDIT_SCALING_SETTINGS'),\n        action: 'edit',\n        onClick: (_, record) => {\n          triggerV3Action({\n            action: 'customScaling.edit.setting',\n            v3Module: 'autoScalingStore',\n            module: 'customScalings',\n            detail: record,\n            cluster: paramsRef.current.cluster,\n            namespace: paramsRef.current.namespace,\n            title: t('KS_AUTOSCALING.EDIT_CUSTOM_SCALING'),\n            success: () => {\n              refetch();\n            },\n          });\n        },\n      },\n      {\n        key: 'delete',\n        icon: <Trash />,\n        text: t('DELETE'),\n        action: 'delete',\n        onClick: (_, record) => {\n          del({ ...record, type: 'KS_AUTOSCALING.CUSTOM_SCALING' });\n        },\n      },\n    ],\n  });\n\n  const renderTableAction = useTableActions({\n    authKey,\n    params: namespaceParams,\n    actions: [\n      {\n        key: 'create',\n        text: t('CREATE'),\n        action: 'create',\n        props: {\n          color: 'secondary',\n          shadow: true,\n        },\n        onClick: () => {\n          triggerV3Action({\n            action: 'customScaling.create',\n            v3Module: 'autoScalingStore',\n            module: 'customScalings',\n            params: {\n              ...commonParams(),\n            },\n            cluster: paramsRef.current.cluster,\n            namespace: paramsRef.current.namespace,\n            title: t('KS_AUTOSCALING.CREATE_CUSTOM_SCALING'),\n            licenseResourceLimit: {\n              scope: 'cluster',\n              key: KEDA_LICENSE_QUOTA_KEY,\n              title: t('KS_AUTOSCALING.CREATE_CUSTOM_SCALING'),\n              params: {\n                cluster: namespaceParams?.cluster,\n              },\n            },\n            success: () => {\n              refetch();\n              reset();\n            },\n          });\n        },\n      },\n    ],\n  });\n\n  const columns = React.useMemo<ColumnDef<Record<string, any>, any>[]>(\n    () => [\n      defaultCheckboxColumn,\n      {\n        accessorKey: 'name',\n        header: t('NAME'),\n        meta: {\n          searchKey: 'name',\n          sortable: true,\n        },\n        cell: info => {\n          return (\n            <Avatar\n              icon={<Stretch size={40} />}\n              title={getDisplayName(info.row.original)}\n              description={info.row.original.description}\n              to={`/clusters/${cluster}/projects/${info.row.original.namespace}/custom-scaling/${info.getValue()}/resource-status`}\n            />\n          );\n        },\n      },\n      {\n        accessorKey: 'status',\n        header: t('STATUS'),\n        meta: {\n          sortable: false,\n          searchKey: 'status',\n        },\n        enableHiding: true,\n        cell: info => (\n          <CustomScalingSimpleStatus\n            isReady={info.row.original.isReady}\n            status={info.row.original.status}\n            toEvent={() => {\n              open({\n                detail: info.row.original,\n                headerTitle: t('KS_AUTOSCALING.EVENTS'),\n              });\n            }}\n          />\n        ),\n      },\n      {\n        accessorKey: 'namespace',\n        header: t('PROJECT'),\n        meta: {\n          searchKey: 'namespace',\n        },\n        cell: info => {\n          return (\n            <Link to={`/clusters/${cluster}/projects/${info.row.original.namespace}/`}>\n              {info.row.original.namespace}\n            </Link>\n          );\n        },\n      },\n      {\n        accessorKey: 'triggers',\n        header: t('KS_AUTOSCALING.SCALER'),\n        meta: {\n          th: {\n            width: '15%',\n          },\n        },\n        enableHiding: true,\n        cell: info => {\n          const { triggers = [] } = info.row.original;\n          const triggersLabel = triggers\n            .map((item: { type?: string }) => capitalize(item.type))\n            .join(',');\n          return triggersLabel;\n        },\n      },\n      {\n        accessorKey: 'scaleTargetRef',\n        header: t('KS_AUTOSCALING.SCALING_OBJECT'),\n        meta: {\n          th: {\n            width: '15%',\n          },\n        },\n        enableHiding: true,\n        cell: info => {\n          return (\n            <Field\n              value={info.row.original.scaleTargetRef?.name ?? '-'}\n              label={\n                KIND_MODULE[info.row.original.scaleTargetRef?.kind]\n                  ? t(KIND_MODULE[info.row.original.scaleTargetRef?.kind].toUpperCase())\n                  : '-'\n              }\n            />\n          );\n        },\n      },\n      {\n        accessorKey: 'minReplicaCount',\n        header: t('KS_AUTOSCALING.MINIMUM_REPLICAS'),\n        meta: {\n          th: {\n            width: '10%',\n          },\n        },\n        enableHiding: true,\n        cell: info => info.getValue() ?? '-',\n      },\n      {\n        accessorKey: 'maxReplicaCount',\n        header: t('KS_AUTOSCALING.MAXIMUM_REPLICAS'),\n        meta: {\n          th: {\n            width: '10%',\n          },\n        },\n        enableHiding: true,\n        cell: info => info.getValue() ?? '-',\n      },\n      {\n        accessorKey: 'createTime',\n        header: t('CREATION_TIME_TCAP'),\n        meta: {\n          sortable: true,\n        },\n        enableHiding: true,\n        cell: info => {\n          const time = info.getValue();\n          if (!time) {\n            return '-';\n          }\n          return getLocalTime(time).format('YYYY-MM-DD HH:mm:ss');\n        },\n      },\n      {\n        accessorKey: 'actions',\n        header: '',\n        meta: {\n          th: {\n            width: 100,\n          },\n        },\n        cell: info => renderItemActions(info.getValue(), info.row.original),\n      },\n    ],\n    [namespace],\n  );\n\n  const baseConfig = React.useState(() =>\n    DataTable.getDefaultTableOptions<Record<string, any>>({\n      tableName: 'workspace-scaledobject-list',\n      manual: true,\n      enableVisible: true,\n      enableSelection: true,\n      enableMultiSelection: true,\n    }),\n  )[0];\n\n  const table = DataTable.useTable<Record<string, any>>({\n    ...baseConfig,\n    columns,\n    loading: isLoading || isFetching,\n    data: data?.data ?? [],\n    rowCount: data?.total ?? 0,\n    onParamsChange: setState,\n    state,\n    getRowId: React.useCallback(row => row.uid, []),\n    meta: {\n      ...baseConfig.meta,\n      refetch,\n      getProps: {\n        table: () => {\n          return {\n            stickyHeader: true,\n            tableWrapperClassName: 'table',\n          };\n        },\n        toolbar: () => {\n          return {\n            toolbarLeft: renderSelect(),\n            batchActions: renderBatchActions(),\n            toolbarRight: renderTableAction(),\n          };\n        },\n        filters: () => {\n          return {\n            simpleMode: false,\n            suggestions: [\n              {\n                key: 'name',\n                label: t('name'),\n              },\n              {\n                key: 'status',\n                label: t('status'),\n                options: [\n                  { key: 'normal', label: t('KS_AUTOSCALING.NORMAL') },\n                  { key: 'abnormal', label: t('KS_AUTOSCALING.ABNORMAL') },\n                  { key: 'creating', label: t('KS_AUTOSCALING.CREATING') },\n                ],\n              },\n            ],\n          };\n        },\n        empty: () => {\n          if (!namespace) {\n            return {\n              image: <Stretch size={40} />,\n              description: t('PLEASE_SELECT_CLUSTER_OR_PROJECT'),\n            };\n          }\n          return {\n            image: <Stretch size={40} />,\n          };\n        },\n      },\n    },\n  });\n\n  React.useEffect(() => {\n    tableRef.current = table;\n  }, []);\n\n  return (\n    <PageLayout title={t('KS_AUTOSCALING.CUSTOM_SCALING_PL')}>\n      <Container>\n        <Card padding={0}>\n          <DataTable.DataTable table={table} />\n        </Card>\n      </Container>\n    </PageLayout>\n  );\n};\n\nexport default CustomScaling;\n"
      },
      {
        "path": "src/pages/clusters/routes.tsx",
        "content": "import * as React from 'react';\nimport { Navigate, Outlet } from 'react-router-dom';\nimport { V3ModalObserver } from '../../components/ExtensionConsoleV3Embed';\nimport { ModalProvider } from '@ks-console/shared';\nimport CustomScaling from './CustomScaling';\nimport Detail from './CustomScaling/Detail/index';\nimport Events from './CustomScaling/Detail/Events';\nimport ResourceStatus from './CustomScaling/Detail/ResourceStatus';\n\nconst PATH = '/clusters/:cluster';\nexport const PROJECT_PATH = '/clusters/:cluster/projects/:namespace';\n\nexport default [\n  {\n    parentRoute: PATH,\n    element: (\n      <>\n        <ModalProvider>\n          <Outlet />\n        </ModalProvider>\n\n        <V3ModalObserver />\n      </>\n    ),\n    children: [\n      {\n        path: `${PATH}/custom-scaling`,\n        element: <CustomScaling />,\n      },\n      {\n        path: `${PROJECT_PATH}/custom-scaling/:name`,\n        element: <Detail />,\n        handle: {\n          menuName: 'custom-scaling',\n        },\n        children: [\n          {\n            path: `resource-status`,\n            element: <ResourceStatus />,\n          },\n          {\n            path: `events`,\n            element: <Events />,\n          },\n        ],\n      },\n    ],\n  },\n];\n"
      },
      {
        "path": "src/pages/workspaces/CustomScaling/index.styles.ts",
        "content": "import styled from 'styled-components';\n\nexport const Container = styled.div`\n  table .table-cell {\n    word-break: break-word;\n  }\n`;\n"
      },
      {
        "path": "src/pages/workspaces/CustomScaling/index.tsx",
        "content": "import {\n  Avatar,\n  BasePathParams,\n  defaultCheckboxColumn,\n  EventsSheet,\n  FormattedCluster,\n  getDisplayName,\n  getLocalTime,\n  hasClusterModule,\n  joinSelector,\n  PageLayout,\n  tableState2Query,\n  useBatchActions,\n  useCommonActions,\n  useItemActions,\n  useModalAction,\n  useTableActions,\n  useUrlSearchParamsStatus,\n} from '@ks-console/shared';\nimport { Card, DataTable, Field } from '@kubed/components';\nimport { Pen, Stretch, Trash } from '@kubed/icons';\nimport { ColumnDef, Table } from '@tanstack/react-table';\nimport { capitalize } from 'lodash';\nimport * as React from 'react';\nimport { useParams } from 'react-router-dom';\nimport { triggerV3Action } from '../../../components/ExtensionConsoleV3Embed';\nimport useWorkspaceClusterSelect from '../../../components/useWorkspaceProjectSelect';\nimport store from '../../../stores/autoScaling';\nimport { Container } from './index.styles';\nimport CustomScalingStatus from '../../../components/CustomScalingStatus';\nimport CustomScalingSimpleStatus from '../../../components/CustomScalingSimpleStatus';\nimport { KEDA_LICENSE_QUOTA_KEY } from '../../../constants/keda';\n\nconst { useQueryList } = store;\nconst authKey = 'autoscaling';\n\nconst steps = [1, 4, 16, 30];\nconst useSteps = (steps: number[]) => {\n  const [stepIndex, setStepIndex] = React.useState(0);\n  return {\n    step: steps[stepIndex],\n    nextStep: () => {\n      if (stepIndex <= steps.length - 1) {\n        setStepIndex(stepIndex + 1);\n      }\n    },\n    reset: () => {\n      setStepIndex(0);\n    },\n  };\n};\n\nconst KIND_MODULE: { [key: string]: string } = {\n  Deployment: 'deployments',\n  StatefulSet: 'statefulsets',\n  DaemonSet: 'daemonsets',\n  Pod: 'pods',\n  deployment: 'deployments',\n  statefulset: 'statefulsets',\n  daemonset: 'daemonsets',\n  pod: 'pods',\n};\n\nconst mapCluster = (cluster: FormattedCluster) => {\n  return {\n    ...cluster,\n    isReady: cluster.isReady && hasClusterModule(cluster.name, 'ks-autoscaling'),\n  };\n};\nconst CustomScaling = () => {\n  const { workspace } = useParams<BasePathParams>();\n  const {\n    paramsRef,\n    params: namespaceParams,\n    render: renderSelect,\n  } = useWorkspaceClusterSelect(\n    {\n      workspace,\n      showAll: false,\n    },\n    list => (list as FormattedCluster[]).map(mapCluster),\n  );\n\n  const { cluster, namespace } = namespaceParams;\n  const { state, setState } = useUrlSearchParamsStatus([]);\n\n  const query = React.useMemo(() => {\n    const { status, ...tableQuery } = tableState2Query(state);\n    const statusQuery = {\n      fieldSelector: undefined as string | undefined,\n    };\n    if (status === 'normal') {\n      statusQuery.fieldSelector = joinSelector({\n        'metadata.annotations.keda\\\\.autoscaling\\\\.kubesphere\\\\.io/ready': 'true',\n      });\n    } else if (status === 'abnormal') {\n      statusQuery.fieldSelector = joinSelector({\n        'metadata.annotations.keda\\\\.autoscaling\\\\.kubesphere\\\\.io/ready': 'false',\n      });\n    } else if (status === 'creating') {\n      statusQuery.fieldSelector = joinSelector({\n        'metadata.annotations.keda\\\\.autoscaling\\\\.kubesphere\\\\.io/ready': 'unknown',\n      });\n    }\n    return {\n      ...tableQuery,\n      ...statusQuery,\n      ...namespaceParams,\n    };\n  }, [state, namespaceParams]);\n\n  const { step, nextStep, reset } = useSteps(steps);\n  const { data, isLoading, isFetching, refetch } = useQueryList(query, {\n    enabled: !!cluster && !!namespace,\n    refetchInterval: step * 1000,\n    onSettled: () => {\n      nextStep();\n    },\n  });\n  const commonParams = () => {\n    return {\n      cluster: paramsRef.current.cluster,\n      namespace: paramsRef.current.namespace,\n    };\n  };\n\n  // const callback = () => refetch();\n\n  const { open } = useModalAction({\n    modal: EventsSheet,\n    id: 'auto-scaling-events',\n  });\n\n  const tableRef = React.useRef<Table<Record<string, any>>>();\n\n  const { editBaseInfo, editYaml, del } = useCommonActions({\n    store: store,\n    params: namespaceParams,\n    callback: callBackType => {\n      if (callBackType === 'delete') {\n        tableRef.current?.resetRowSelection();\n        reset();\n      }\n      refetch();\n    },\n  });\n\n  const renderBatchActions = useBatchActions({\n    authKey,\n    params: namespaceParams,\n    actions: [\n      {\n        key: 'delete',\n        text: t('DELETE'),\n        action: 'delete',\n        onClick: () => {\n          const resource = tableRef.current?.getSelectedRowModel()?.rows.map(row => row.original!);\n          const k8sVersion = globals.clusterConfig?.[paramsRef.current.cluster!]?.k8sVersion;\n          del({ resource, type: 'KS_AUTOSCALING.CUSTOM_SCALING' }, k8sVersion);\n        },\n        props: {\n          color: 'error',\n        },\n      },\n    ],\n  });\n\n  const renderItemActions = useItemActions({\n    // authKey,\n    params: namespaceParams,\n    actions: [\n      {\n        key: 'edit',\n        icon: <Pen />,\n        text: t('EDIT_INFORMATION'),\n        action: 'edit',\n        onClick: (_, record) => {\n          const k8sVersion = globals.clusterConfig?.[paramsRef.current.cluster!]?.k8sVersion;\n          editBaseInfo(record, k8sVersion);\n        },\n      },\n      {\n        key: 'editYaml',\n        icon: <Pen />,\n        text: t('EDIT_YAML'),\n        action: 'edit',\n        onClick: (_, record) => {\n          editYaml(record);\n        },\n      },\n      {\n        key: 'editScale',\n        icon: <Pen />,\n        text: t('KS_AUTOSCALING.EDIT_SCALING_SETTINGS'),\n        action: 'edit',\n        onClick: (_, record) => {\n          triggerV3Action({\n            action: 'customScaling.edit.setting',\n            v3Module: 'autoScalingStore',\n            module: 'customScalings',\n            detail: record,\n            cluster: paramsRef.current.cluster,\n            namespace: paramsRef.current.namespace,\n            title: t('KS_AUTOSCALING.EDIT_CUSTOM_SCALING'),\n            success: () => {\n              refetch();\n            },\n          });\n        },\n      },\n      {\n        key: 'delete',\n        icon: <Trash />,\n        text: t('DELETE'),\n        action: 'delete',\n        onClick: (_, record) => {\n          del({ ...record, type: 'KS_AUTOSCALING.CUSTOM_SCALING' });\n        },\n      },\n    ],\n  });\n\n  const renderTableAction = useTableActions({\n    authKey,\n    params: namespaceParams,\n    actions: [\n      {\n        key: 'create',\n        text: t('CREATE'),\n        action: 'create',\n        props: {\n          color: 'secondary',\n          shadow: true,\n        },\n        disabled: !cluster || !namespace,\n        onClick: () => {\n          triggerV3Action({\n            action: 'customScaling.create',\n            v3Module: 'autoScalingStore',\n            module: 'customScalings',\n            params: {\n              ...commonParams(),\n            },\n            licenseResourceLimit: {\n              scope: 'namespace',\n              key: KEDA_LICENSE_QUOTA_KEY,\n              title: t('KS_AUTOSCALING.CREATE_CUSTOM_SCALING'),\n              params: {\n                cluster: namespaceParams?.cluster,\n                namespace: paramsRef.current.namespace,\n              },\n            },\n            cluster: paramsRef.current.cluster,\n            namespace: paramsRef.current.namespace,\n            title: t('KS_AUTOSCALING.CREATE_CUSTOM_SCALING'),\n            success: () => {\n              refetch();\n              reset();\n            },\n          });\n        },\n      },\n    ],\n  });\n\n  const columns = React.useMemo<ColumnDef<Record<string, any>, any>[]>(\n    () => [\n      defaultCheckboxColumn,\n      {\n        accessorKey: 'name',\n        header: t('NAME'),\n        meta: {\n          searchKey: 'name',\n          sortable: true,\n        },\n        cell: info => {\n          return (\n            <Avatar\n              icon={<Stretch size={40} />}\n              title={getDisplayName(info.row.original)}\n              description={info.row.original.description}\n              to={`/${workspace}/clusters/${paramsRef.current.cluster}/projects/${paramsRef.current.namespace}/custom-scaling/${info.getValue()}/resource-status`}\n            />\n          );\n        },\n      },\n      {\n        accessorKey: 'status',\n        header: t('STATUS'),\n        meta: {\n          sortable: false,\n          searchKey: 'status',\n        },\n        enableHiding: true,\n        cell: info => (\n          <CustomScalingSimpleStatus\n            isReady={info.row.original.isReady}\n            status={info.row.original.status}\n            toEvent={() => {\n              open({\n                detail: info.row.original,\n                headerTitle: t('KS_AUTOSCALING.EVENTS'),\n              });\n            }}\n          />\n        ),\n      },\n      {\n        accessorKey: 'triggers',\n        header: t('KS_AUTOSCALING.SCALER'),\n        meta: {\n          th: {\n            width: '15%',\n          },\n        },\n        enableHiding: true,\n        cell: info => {\n          const { triggers = [] } = info.row.original;\n          const triggersLabel = triggers\n            .map((item: { type?: string }) => capitalize(item.type))\n            .join(',');\n          return triggersLabel;\n        },\n      },\n      {\n        accessorKey: 'scaleTargetRef',\n        header: t('KS_AUTOSCALING.SCALING_OBJECT'),\n        meta: {\n          th: {\n            width: '15%',\n          },\n        },\n        enableHiding: true,\n        cell: info => {\n          return (\n            <Field\n              value={info.row.original.scaleTargetRef?.name ?? '-'}\n              label={\n                KIND_MODULE[info.row.original.scaleTargetRef?.kind]\n                  ? t(KIND_MODULE[info.row.original.scaleTargetRef?.kind].toUpperCase())\n                  : '-'\n              }\n            />\n          );\n        },\n      },\n      {\n        accessorKey: 'minReplicaCount',\n        header: t('KS_AUTOSCALING.MINIMUM_REPLICAS'),\n        meta: {\n          th: {\n            width: '10%',\n          },\n        },\n        enableHiding: true,\n        cell: info => info.getValue() ?? '-',\n      },\n      {\n        accessorKey: 'maxReplicaCount',\n        header: t('KS_AUTOSCALING.MAXIMUM_REPLICAS'),\n        meta: {\n          th: {\n            width: '10%',\n          },\n        },\n        enableHiding: true,\n        cell: info => info.getValue() ?? '-',\n      },\n      {\n        accessorKey: 'createTime',\n        header: t('CREATION_TIME_TCAP'),\n        meta: {\n          sortable: true,\n        },\n        enableHiding: true,\n        cell: info => {\n          const time = info.getValue();\n          if (!time) {\n            return '-';\n          }\n          return getLocalTime(time).format('YYYY-MM-DD HH:mm:ss');\n        },\n      },\n      {\n        accessorKey: 'actions',\n        header: '',\n        meta: {\n          th: {\n            width: 100,\n          },\n        },\n        cell: info => renderItemActions(info.getValue(), info.row.original),\n      },\n    ],\n    [namespace],\n  );\n\n  const baseConfig = React.useState(() =>\n    DataTable.getDefaultTableOptions<Record<string, any>>({\n      tableName: 'workspace-scaledobject-list',\n      manual: true,\n      enableVisible: true,\n      enableSelection: true,\n      enableMultiSelection: true,\n    }),\n  )[0];\n\n  const table = DataTable.useTable<Record<string, any>>({\n    ...baseConfig,\n    columns,\n    loading: isLoading || isFetching,\n    data: data?.data ?? [],\n    rowCount: data?.total ?? 0,\n    onParamsChange: setState,\n    state,\n    getRowId: React.useCallback(row => row.uid, []),\n    meta: {\n      ...baseConfig.meta,\n      refetch,\n      getProps: {\n        table: () => {\n          return {\n            stickyHeader: true,\n            tableWrapperClassName: 'table',\n          };\n        },\n        toolbar: () => {\n          return {\n            toolbarLeft: renderSelect(),\n            batchActions: renderBatchActions(),\n            toolbarRight: renderTableAction(),\n          };\n        },\n        filters: () => {\n          return {\n            simpleMode: false,\n            suggestions: [\n              {\n                key: 'name',\n                label: t('name'),\n              },\n              {\n                key: 'status',\n                label: t('status'),\n                options: [\n                  { key: 'normal', label: t('KS_AUTOSCALING.NORMAL') },\n                  { key: 'abnormal', label: t('KS_AUTOSCALING.ABNORMAL') },\n                  { key: 'creating', label: t('KS_AUTOSCALING.CREATING') },\n                ],\n              },\n            ],\n          };\n        },\n        empty: () => {\n          if (!namespace) {\n            return {\n              image: <Stretch size={40} />,\n              description: t('PLEASE_SELECT_CLUSTER_OR_PROJECT'),\n            };\n          }\n          return {\n            image: <Stretch size={40} />,\n          };\n        },\n      },\n    },\n  });\n\n  React.useEffect(() => {\n    tableRef.current = table;\n  }, []);\n\n  return (\n    <PageLayout title={t('KS_AUTOSCALING.CUSTOM_SCALING_PL')}>\n      <Container>\n        <Card padding={0}>\n          <DataTable.DataTable table={table} />\n        </Card>\n      </Container>\n    </PageLayout>\n  );\n};\n\nexport default CustomScaling;\n"
      },
      {
        "path": "src/pages/workspaces/routes.tsx",
        "content": "import * as React from 'react';\nimport { Outlet } from 'react-router-dom';\nimport CustomScaling from './CustomScaling';\nimport { V3ModalObserver } from '../../components/ExtensionConsoleV3Embed';\nimport { ModalProvider } from '@ks-console/shared';\nimport Detail from '../clusters/CustomScaling/Detail';\nimport ResourceStatus from '../clusters/CustomScaling/Detail/ResourceStatus';\nimport Events from '../clusters/CustomScaling/Detail/Events';\n\nconst PATH = '/workspaces/:workspace';\nexport const PROJECT_PATH = '/:workspace/clusters/:cluster/projects/:namespace';\n\nexport default [\n  {\n    parentRoute: PATH,\n    element: (\n      <>\n        <ModalProvider>\n          <Outlet />\n        </ModalProvider>\n\n        <V3ModalObserver />\n      </>\n    ),\n    children: [\n      {\n        path: `${PATH}/custom-scaling`,\n        element: <CustomScaling />,\n      },\n    ],\n  },\n  {\n    parentRoute: PROJECT_PATH,\n    element: (\n      <>\n        <ModalProvider>\n          <Outlet />\n        </ModalProvider>\n        <V3ModalObserver />\n      </>\n    ),\n    children: [\n      {\n        path: `${PROJECT_PATH}/custom-scaling/:name`,\n        element: <Detail />,\n        children: [\n          {\n            path: `resource-status`,\n            element: <ResourceStatus />,\n          },\n          {\n            path: `events`,\n            element: <Events />,\n          },\n        ],\n      },\n    ],\n  },\n];\n"
      },
      {
        "path": "src/routes/index.tsx",
        "content": "import React from 'react';\nimport workspaceRoutes from '../pages/workspaces/routes';\nimport clusterRoutes from '../pages/clusters/routes';\nexport const routes = [...workspaceRoutes, ...clusterRoutes];\n"
      },
      {
        "path": "src/stores/autoScaling.ts",
        "content": "import {\n  BaseStore,\n  getBaseInfo,\n  getOriginData,\n  getPath,\n  PathParams,\n  storeHooks,\n} from '@ks-console/shared';\nimport { get } from 'lodash';\n\nconst { getStoreWithQueryHooks } = storeHooks;\n\nconst mapper = (item: Record<string, any>) => {\n  const baseInfo = getBaseInfo(item);\n  const {\n    scaleTargetRef,\n    triggers = [],\n    pollingInterval,\n    cooldownPeriod,\n    minReplicaCount,\n    maxReplicaCount,\n    advanced,\n  } = item?.spec ?? {};\n\n  let isReadyString = get(item, 'metadata.annotations[\"keda.autoscaling.kubesphere.io/ready\"]', 'false');\n  let isReady = isReadyString === 'true' || isReadyString === true;\n  let isCreating = isReadyString === 'unknown';\n\n  return {\n    ...baseInfo,\n    minReplicas: get(item, 'spec.minReplicas'),\n    maxReplicas: get(item, 'spec.maxReplicas'),\n    status: get(item, 'status', {}),\n    workspace: get(item, 'metadata.labels[\"kubesphere.io/workspace\"]', ''),\n    scaleTargetRef,\n    triggers,\n    pollingInterval,\n    cooldownPeriod,\n    minReplicaCount,\n    maxReplicaCount,\n    advanced,\n    isReady,\n    isCreating,\n    namespace: get(item, 'metadata.namespace'),\n    _originData: getOriginData(item),\n  };\n};\n\nconst module = 'scaledobjects';\n\nconst apiVersion = 'kapis/keda.sh/v1alpha1';\n\nconst getUrl = (params: PathParams = {}) => {\n  return `${apiVersion}/${getPath(params)}/${module}`;\n};\n\nconst baseStore = BaseStore({\n  module,\n  apiVersion,\n  mapper,\n  getResourceUrlFn: getUrl,\n  getListUrlFn: getUrl,\n});\n\nexport default getStoreWithQueryHooks(baseStore);\n"
      },
      {
        "path": "src/utils.ts",
        "content": ""
      }
    ],
    "externals": [
    ]
  }